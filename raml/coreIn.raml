#%RAML 0.8
---
title: TAS core incoming (app -> TAS)
baseUri: http://talentappstore.com/{version}
version: v1


/apps:
  description: An *app* is a microservice that can be installed by a tenant
  /{app}:
    get:
      description: |
        Get details of the app. Can only be called by the app itself. This useful when some piece of software (like a proxy)
        is acting on behalf of the app, but has only been given its shortCode and secret key.
      responses:
        200:
          body:
            application/json:
              schema: !include ../schemas/app.json
              example: !include ../examples/app-simple.json

/OAuthKey:
  description: The public key used to verify that OAuth tokens were correctly signed by TAS.
  get:
    description: Get the current public key used by TASA to sign OAuth tokens.
    responses:
      200:
        body:
          text/plain:
            example: kuh9876guhgfyr76453dytrfUTYGuytfUrt

/patchSets:
  post:
    description: |
      This endpoint behaves exactly as per /tenants/{tenant}/patchSets, except that it creates a tenant rather than applying patches
      to an existing tenant.
  /{launchKey}:
    post:
      description: |
        This endpoint behaves exactly as per /tenants/{tenant}/patchSets/{launchKey}, except that it works against a tenant-creating patchSet,
        e.g. initial tenant creation, or copy, rather than a patchSet that is modifying an existing tenant.

                  
/ping:
  description: A ping is the simplest call an app can make against the TAS core
  get:
    description: Always return http 200. Useful for testing app is working OK (has correct secret key etc.).
    responses:
      200:
      403:


/routes:
  description: |
    Routes are usages of a specific tenant API, on a specific producing app, by a specific consuming app.
    Your app needs to first fetch a route in order to consume an API. The route will tell your app about
    the actual endpoint (where the producer's server sits on the internet).
    Routes are also useful to the producer of an API, e.g. to validate the methods (POST, GET, etc.)
    that the consumer is allowed to call.
  /{CT}:
    description: |
      Consuming tenant: the tenant with the app installed that is consuming the API
    /{CA}:
      description: |
        Consuming app: the app consuming the API
      /{ADEV}:
        description: |
           Developer who defined the API
        /{URI}:
          description: |
            API URI Template: the URI template (as per https://tools.ietf.org/html/rfc6570) of the API being consumed
          /{SOT}:
            description: |
              True if the consuming app is consuming this as SoT (source of truth), otherwise false
            get:
              description: | 
                Used by tenant API consumers to fetch the route(s) from the consumer to each producer of a specific API.
                  
                The core will check that:
                - the app making the core API call is the consuming app (i.e., matches {CA})
                - the consuming app is installed at {CT}
                - the consuming app has declared that it consumes the given API, in the given way (SoT or not).
              responses:
                200:
                  body:
                    application/json:
                      schema: !include ../schemas/routes.json
                      example: !include ../examples/routes-simple.json
          /{PT}:
            description: |
              Producing tenant: the tenant with the app installed that is producing the API
            /{PA}:
              description: |
                Producing app: the app producing the API
              get:
                description: |

                  Used by tenant API producers to verify that the consumer is allowed to consume this API.

                  The core will check that:
                  - the app making the core API call is the producing app (i.e., matches {PA})
                  - the producing app is installed at {PT}
                  - the consuming app has declared that it consumes the given API
                  - the producing app has declared that it produces the given API
                  - the consuming app has declared that it consumes the given API in the same way that the producer has declared that it produces it (SoT or not).
                 
                  Since both consuming and producing apps are specified, there can only be one or zero routes in the response.

                responses:
                  200:
                    body:
                      application/json:
                        schema: !include ../schemas/route.json
                        example: !include ../examples/route-simple.json

/saml:
  /assertions:
    /{PT}:
      /{key}:
        get:
          description: Fetch a SAML assertion via its database key.
          responses:
            200:
              body:
                application/xml:
              
  /keyLookups:
    /{PT}:
      description: the principal type the assertion is for
      post:
        description: |
          Used by apps which include their own SAML SP layer (rather than sitting behind the proxy) to obtain the database key
          of the incoming SAML assertion. TAS acts as a SAML proxy, and captures and stores assertions in an internal
          database, partitioned by principal type, prior to handing them off to the app (SP).

          The assertion to search for is passed in the request body.
           
          The core will:
          - check if the app making the call is linked to the stated principal type, and fail if not
          - check whether the assertion has expired, and fail if so
          - search its internal SAML assertions database for the assertion, and fail if not found
          - pass back the assertion's reference
        body:
          application/xml:
              
/tenants:  
  description: |
    A *tenant* is a customer within the multi-tenanted environment of Talent App Store.
  /{tenant}:
    get:
      description: |
        Get details of the tenant.
        
        The core will:
        - check that the app is installed by the tenant, and fail if not. 
      responses:
        200:
          body:
            application/json:
              schema: !include ../schemas/tenant.json
              example: !include ../examples/tenant-simple.json
    /status:
      get:
        description: |
          Get the status of the tenant, including the current state and security generation. Normally apps would use this information
          when restarting to determine whether to flush cached OAuth tokens and routes.
          
          The core will:
          - check that the app is installed by the tenant, and fail if not. 
        responses:
          200:
            body:
              application/json:
                schema: !include ../schemas/tenantStatus.json
                example: !include ../examples/tenantStatus-simple.json

    /samlSPMetadata:
      description: Apps that are SSO-protected (i.e., SPs in SAML lingo) require their own SAML metadata, referred to as the SP metadata.
      /{principalDeveloper}:
        /{principalType}:
          get:
            description: Get the metadata for this app (the SP).
    /samlIdPMetadata:
      description: |
        Apps that are SSO-protected (i.e., SPs in SAML lingo) require the SAML metadata for the IdP proxy that front ends all of the
        identity providers that the tenant has set up for the given principal type. 
      /{principalDeveloper}:
        /{principalType}:
          get:
            description: Get the metadata for the IdP proxy.
    /OAuthFlushes:
      post:
        description: |
          This endpoint is available only to apps tagged as "storeFront".
          
          Your app calls this endpoint to reboot the tenant and increment the security generation. This effectively
          (since apps should always check for changed security generation) invalidates all OAuth tokens for
          APIs consumed or produced by this tenant. This is used to mitigate an attack where an app has an OAuth token
          stolen from it (tenant admin person clicks "Flush credentials" in the storefront).
          
          The response body is an unguessable unique "launch key" which can be used with POST /tenants/{tenant}/reboots/{launchKey}.
           
        body:
          application/json:
            schema: !include ../schemas/patchSetPreparer.json
            example: !include ../examples/patchSetPreparer-installApp.json
        responses:
          200:
            body:
              application/json:
                schema: !include ../schemas/patchSetLaunchKey.json
                example: !include ../examples/patchSetLaunchKey-simple.json
    /patchSets:
      post:
        description: |
          This endpoint is available only to apps tagged as "storeFront".
          
          Your app calls this endpoint to validate and then prepare a patch document, e.g. to reflect the tenant clicking install on an app.
          
          The response body is an unguessable unique "launch key" which can be used with POST /tenants/{tenant}/reboots/{launchKey}.
          
          Pass true for "bumpSecurityGeneration" to force the security generation to be incremented. 
        body:
          application/json:
            schema: !include ../schemas/patchSetPreparer.json
            example: !include ../examples/patchSetPreparer-installApp.json
        responses:
          200:
            body:
              application/json:
                schema: !include ../schemas/patchSetLaunchKey.json
                example: !include ../examples/patchSetLaunchKey-simple.json
    /reboots:                
      /{launchKey}:
        post:
          description: |
            Launch a previously prepared reboot (if not already launched), and get the latest events and the current summary
            details.
            
            This endpoint is unauthenticated and has CORS headers that allow access from any domain (since the javascript calling it
            belongs to a storefront app which does not share the same domain as the tas core).
            
            If the apply is already "complete" then this call will return immediately, with any events that match the filter,
            up to the maximum events per call (100).
            
            Otherwise, the call blocks for .5 seconds to avoid thrashing, then returns as soon as at least one event is
            available that matches the filter, or the apply becomes complete (which would always be accompanied by an event).
            If no events are available after 60 seconds, the call returns indicating a timeout - the client will typically
            immediately make another call in a typical long-polling pattern, until the apply is marked as complete and the
            last event has been fetched.
          queryParameters:
            afterEvent:
              type: integer
              description: |
                The sequence of an existing event - this call should return events immediately *after* this event.
                Omitting this parameter returns the first events.
              example: 12
              required: false
          responses:
            200:
              body:
                application/json:
                  schema: !include ../schemas/rebootStatus.json
                  example: !include ../examples/rebootStatus-juggleApps.json

                            
/token:
  description: |
    Used by tenant API consumers to obtain an OAuth token, i.e. that an app installed at a tenant (the consuming app) can use to consume tenant
    APIs on a specific app installed at a tenant (the producing app). Currently, producing and consuming tenants are always the same.
    Tokens may further be personal, i.e. principal-aware, in which case they also identify the end user.
    
    The request body must be of content-type application/x-www-form-urlencoded, and contain values for grant_type
    and optionally other parameters, encoded as per	https://tools.ietf.org/html/rfc6749#appendix-B.
    See also https://tools.ietf.org/html/rfc7522#section-4.

    OAuth access tokens in TAS are self-contained security tokens in the form of a JWT (json web token; see http://jwt.io/).
    Because access tokens are self-contained and signed, producers can rely on their content without any network
    traffic to the authorization server (i.e. TAS).

    Before issuing a token, the core checks that:
    - the consuming app is installed at the consuming tenant
    - the producing app is installed at the producing tenant
    - there exists at least one route between the consumer and producer, for any API (this prevents apps probing for
    the presence of other apps)
        
    Every call to this endpoint results in a new access token being issued, with an expiry time set to one hour, or
    (as per http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithSAML.html) to the time specified in the SAML
    assertion's SessionNotOnOrAfter value (if present), whichever is shorter.
    
    If SessionNotOnOrAfter is in the past then token creation fails, and the app must somehow force the user to reauthenticate.
    
    For efficiency consumers should cache the tokens returned by this endpoint until (a) the tenant's security generation
    number changes, or (b) the cached token is too close to expiry to serve the needs of the consumer.

  post:
    description: |
      Get a new access token, and optionally a refresh token.

    body:
      application/x-www-form-urlencoded:
        formParameters:
          grant_type:
            description: |
               One of:
               - client_credentials
               - urn:ietf:params:oauth:client-assertion-type:saml2-bearer
               - urn:talentappstore.com:oauth:saml2-bearer-ref
               - urn:talentappstore.com:oauth:tas-inherited
               - refresh_token
            type: string
            example: refresh_token
          scope:
            description: |
              A space separated set of values for the OAuth scope of this token, which may include: 
              - A string starting with "/" that denotes a consuming app installed at a specific tenant
              and a producing app installed at a specific tenant (MUST be present for all grant types other than refresh_token)
              - the keyword "offline" (MAY be present only when grant_type is urn:ietf:params:oauth:client-assertion-type:saml2-bearer)
            type: string
            example: /acme/jobboard/acme/ats offline 
          refresh_token:
            description: |
              A refresh token obtained via a previous call to this endpoint with scope of offline. MUST be present when grant_type is
              refresh_token. MUST NOT be present for other grant types.
            type: string
          parent_token:
            description: |
              An access token passed in to the consuming app. MUST be present when grant_type is urn:talentappstore.com:oauth2:tas-inherited.
              MUST NOT be present for other grant types.
            type: string
          assertion:
            description: |
              The incoming SAML assertion. MUST be present for grant_type of urn:ietf:params:oauth:client-assertion-type:saml2-bearer.
              MUST NOT be present for other grant types. MUST contain an unexpired SAML assertion that matches exactly one as captured
              and stored by the TAS SAML proxy during login.
          assertion_ref:
            description: |
              A reference to the incoming SAML assertion. MUST be present for grant_type of urn:talentappstore.com:oauth:saml2-bearer-ref.
              MUST NOT be present for other grant types. MUST contain a valid reference to an unexpired SAML assertion as captured
              and stored by the TAS SAML proxy during login.
    responses:
      200:
        body:
          application/json:
            schema: !include ../schemas/tokenJwt.json
            example: !include ../examples/tokenJwt-simple.json

