#%RAML 0.8
---
title: TAS core incoming (app -> TAS)
baseUri: http://talentappstore.com/{version}
version: v1

/tenants:  
  description: |
    A *tenant* is a customer within the multi-tenanted environment of Talent App Store.
  /{tenant}:
    /status:
      get:
        description: |
          Get the status of the tenant, including the current state and security generation. Normally apps would keep use this information
          when halted or started to determine whether to flush cached OAuth tokens and routes.
        responses:
          200:
            body:
              application/json:
                schema: !include ../schemas/tenantStatus.json
                example: !include ../examples/tenantStatus-simple.json
    /headlessAuthentications:
      /{principalDeveloper}:
        /{principalType}:
          /viaVerifiedEmail:
            /{email}:
              post:
                description: |
                  This endpoint is available only to apps tagged as "headless authenticators".

                  Useful for:
                  - adding "work on behalf of" behaviour (e.g. a recruiter logs in and works on behalf of a candidate)
                  - when creating a new user (or candidate), finding existing auth info and reusing it
                            
                  Your app can call this API to to headlessly log in as the principal with the given email address, assuming:
                  - they already have a row with that email in the users table of some SoT app
                  - that row is tagged with {E} and {N}, where {E} is for a non-attribute supplying idp (e.g., Google, email, backdoor idp).
              
                  Example:
                  - your app wants to create a job application for fred@acme.com, but is cognisant that Fred may already have a record, maybe authenticated via Google or whatever; so
                  - your app calls POST /tenants/acme/headlessAuthentications/tas/candidate/viaVerifiedEmail/fred@acme.com
                  - TAS starts preparing its response:
                  - On all apps marked as "principal holders" (i.e, apps that have SoT user tables), TAS calls GET /tenants/acme/m/principals/tas/candidate/byEmail/fred@acme.com
                  - the fancycruit app responds first - it does hold a record for fred@acme.com, and so replies with:
                  { "E": "acme-tas-candidate-google-idp", "N": "1246349464" }
                  - TAS synthesizes a SAML assertion with the given E and N and stops asking other apps (i.e. no testing is done for conflicting /E/N values for fred - something for apps to build at some stage)
                  - TAS processes the SAML assertion just as if fred had logged in, e.g. session decoration happens
                  - if no "principal holder" app responds, then no SAML assertion is returned and your app can assume no candidate exists
                  - Finally TAS replies to your app. Your app can now access /E/N, request OAuth tokens, and generally act as if fred had logged in

                  Because this API allows apps to log in on behalf of users, tenants must have complete trust in the integrity of your app, and also that your app
                  *always* verifies that the email address does belong to the end user. Not verifying email addresses opens a security hole.    
    /sessions:
      /viaLogin:
        /{app}:
          description: |
            Your app, i.e. the SSO-protected web site where the principal authenticated.
          /{E}:
            description: |
              The entityID of the currently logged in principal, as passed to your app's SSO-protected web site (see details of authentication).
            /{N}:
              description: |
                The nameID of the currently logged in principal, as passed to your app's SSO-protected web site (see details of authentication).
              get:
                description: |
                  Fetch principal's TAS session using details from the SAML assertion passed when they logged in.
      /viaToken:
        /{accessToken}:
          description: The OAuth access token (a JWT) passed in to the producing app
          get:
            description: |
              Fetch principal's TAS session using details from an OAuth token

    /samlSPMetadata:
      description: Apps that are SSO-protected (i.e., SPs in SAML lingo) require their own SAML metadata, referred to as the SP metadata.
      /{principalDeveloper}:
        /{principalType}:
          get:
            description: Get the metadata for this app (the SP).
    /samlIdPMetadata:
      description: |
        Apps that are SSO-protected (i.e., SPs in SAML lingo) require the SAML metadata for the IdP proxy that front ends all of the
        identity providers that the tenant has set up for the given principal type. 
      /{principalDeveloper}:
        /{principalType}:
          get:
            description: Get the metadata for the IdP proxy.
    /samlSubjects:
      description: |
        <p><b>All APIs to obtain samlSubjects are deprecated. We now expect apps to be able to parse the samlSubject directly
        from the incoming assertion. This document will be removed once it has a new home.</b></p>
        <p>A samlSubject is the primary key, assembled from information in the SAML assertion from the IdP, of the current logged in user.
        The samlSubject is useful
        when your app wants to get some more detail about the user such as their name, email, etc, by calling SCIM APIs
        like /employees/{samlSubject}, etc. - these APIs require a samlSubject.</p>
        <p>By "current logged in user", we mean someone logged into this app (if this app is an SSO-protected app) or another app
        higher up the chain (if this app is an API server producing an OAuth API).</p>
        <p>samlSubject is a string made up of values extracted from the SAML authentication assertion information that
        was captured by TAS when this user logged in to an SSO-protected app, likely to include: 
        <ul>
        <li>Name ID</li>
        <li>Name Qualifier</li>
        <li>Entity ID of the issuing IdP</li>
        </ul>
        <p>The actual SAML items above are not yet confirmed, nor do we have a any standard approach to requesting them in SAML assertions
        or extracting them from SAML assertions. But in any case the set will uniquely identify the user, even across
        multiple possible authenticating IdPs. For example, "candidates" may be held across a number of IdPs, including corporate IdP
        (internal candidates), Facebook pseudo-IdP, etc.</p>
        <p>samlSubjects are identical across all SP's (i.e., all TAS SSO-protected apps), so that apps can
        correlate the user's identity (i.e. they each have the same understanding of who a user is). This means that transient SAML
        identifiers for example cannot be used.
        </p>
        <p>API servers can extract the samlSubject from the sub field of the incoming OAuth access token.</p>
        <p>Because access tokens are generated and signed by TAS, the user's identity can be passed securely down through a chain of
        OAuth API calls, while preventing malicious apps from acting on behalf of a user who has not logged in.</p>
        <p>Each producing app in the chain gets their chance to enforce their own business rules and make further
        tenant API calls on behalf of the logged in user.</p>     
      /viaSamlAssertion:
        post:
          description: |
            <p><b>All APIs to obtain samlSubjects are deprecated. We now expect apps to be able to parse the samlSubject directly
            from the incoming assertion. This document will be removed once it has a new home.</b></p>
            If your app is an SSO-protected web site, then it can exchange the SAML authentication assertion that it received at
            login time for the samlSubject by using this endpoint and passing the assertion as the request body.
          body:
            application/xml:
          responses:
            200:
              body:
                application/json:
                  schema: !include ../schemas/samlSubject.json
                  example: !include ../examples/samlSubject-simple.json
    /patchSets:
      post:
        description: |
          This endpoint is available only to apps tagged as "storeFront".
          
          Your app calls this endpoint to validate and then prepare a patch document, e.g. to reflect the tenant clicking install on an app.
          
          The response body is an unguessable unique "launch key" which can be used with POST /tenants/{tenant}/patchSets/{launchKey}.
          
          Pass true for "bumpSecurityGeneration" to force the security generation to be incremented. 
        body:
          application/json:
            schema: !include ../schemas/patchSetPreparer.json
            example: !include ../examples/patchSetPreparer-installApp.json
        responses:
          200:
            body:
              application/json:
                schema: !include ../schemas/patchSetLaunchKey.json
                example: !include ../examples/patchSetLaunchKey-simple.json
      /{launchKey}:
        post:
          description: |
            Launch a previously prepared patch document (if not already launched), and get the latest events and the current summary
            details for the patch document.
            
            This endpoint is unauthenticated and has CORS headers that allow access from any domain (since the javascript calling it
            belongs to a storefront app which does not share the same domain as the tas core).
            
            If the apply is already "complete" then this call will return immediately, with any events that match the filter,
            up to the maximum events per call (100).
            
            Otherwise, the call blocks for .5 seconds to avoid thrashing, then returns as soon as at least one event is
            available that matches the filter, or the apply becomes complete (which would always be accompanied by an event).
            If no events are available after 60 seconds, the call returns indicating a timeout - the client will typically
            immediately make another call in a typical long-polling pattern, until the apply is marked as complete and the
            last event has been fetched.
          queryParameters:
            afterEvent:
              type: integer
              description: |
                The sequence of an existing event - this call should return events immediately *after* this event.
                Omitting this parameter returns the first events.
              example: 12
              required: false
          responses:
            200:
              body:
                application/json:
                  schema: !include ../schemas/patchSetStatus.json
                  example: !include ../examples/patchSetStatus-juggleApps.json

/routes:
  description: |
    Routes are usages of a specific tenant API, on a specific producing app, by a specific consuming app.
    Your app needs to first fetch a route in order to consume an API. The route will tell your app about
    the actual endpoint (where the producer's server sits on the internet).
    Routes are also useful to the producer of an API, e.g. to validate the methods (POST, GET, etc.)
    that the consumer is allowed to call.
  /{CT}:
    description: |
      Consuming tenant: the tenant with the app installed that is consuming the API
    /{CAD}:
      description: |
        Consuming app developer: the developer who owns the app consuming the API
      /{CA}:
        description: |
          Consuming app: the app consuming the API
        /{AD}:
          description: |
            API developer: the developer who owns/defines the API being consumed
          /{URI}:
            description: |
              API URI Template: the URI template (as per https://tools.ietf.org/html/rfc6570) of the API being consumed
            /{SOT}:
              description: |
                Consuming as Source of Truth: true if the app is consuming this as a source of truth API, otherwise false
              get:
                description: | 
                  Fetch the route(s) from the consumer to each producer of a specific API
                responses:
                  200:
                    body:
                      application/json:
                        schema: !include ../schemas/routes.json
                        example: !include ../examples/routes-simple.json
        /{PT}:
          description: |
            Producing tenant: the tenant with the app installed that is producing the API
          /{PAD}:
            description: |
              Producing app developer: the developer who owns the app producing the API
            /{PA}:
              description: |
                Producing app: the app producing the API
              /{AD}:
                description: |
                  API developer: the developer who owns/defines the API being consumed
                /{URI}:
                  description: |
                    API URI Template: the URI template (as per https://tools.ietf.org/html/rfc6570) of the API being consumed
                  get:
                    description: | 
                      Fetch the route, from the given consumer, to the producer (which must be your app)
                      of a specific API. Since both consuming and producing apps are specified, there can only be
                      one or zero routes in the response.
                    responses:
                      200:
                        body:
                          application/json:
                            schema: !include ../schemas/route.json
                            example: !include ../examples/route-simple.json
                            
/token:
  description: |
    TAS OAuth access tokens are self-contained security tokens in the form of a JWT (json web token; see http://jwt.io/).
    
    An access token authorizes a specific consuming app to consume APIs at a specific producing app.
    
    Because access tokens are self-contained and signed, producers can rely on their content without any network
    traffic to the authorization server (i.e. TAS).
    
    Every call to this endpoint results in a new access token being issued, with an expiry time set to one hour, or
    (as per http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithSAML.html) to the time specified in the SAML
    assertion's SessionNotOnOrAfter value (if present), whichever is shorter.
    
    If SessionNotOnOrAfter is in the past then token creation fails, and the app must somehow force the user to reauthenticate.
    
    For efficiency consumers should cache the tokens returned by this endpoint until (a) the tenant's security generation
    number changes, or (b) the cached token is too close to expiry to serve the needs of the consumer.
  post:
    description: Get a new access token, and optionally a refresh token
    queryParameters:
      grant_type:
        description: |
           One of:
           - urn:talentappstore.com:oauth2:tas-direct
           - urn:talentappstore.com:oauth2:tas-inherited
           - refresh_token
           
        type: string
        example: refresh_token
      scope:
        description: |
          A space separated set of values for the OAuth scope of this token, which may include: 
          - A string starting with "/" that denotes a consuming app installed at a specific tenant
          and a producing app installed at a specific tenant (MUST be present for all grant types other than refresh_token)
          - the keyword "offline" (MAY be present when grant_type is urn:talentappstore.com:oauth2:tas-direct
          and the principal type parameters are present)         
        type: string
        example: /acme/smartyhr/ats/greenjobsite/greenjobs/gjcore offline 
      entityID:
        description: |
          The entity ID from the SAML assertion when this user logged in (MAY be present only when grant_type is
          urn:talentappstore.com:oauth2:tas-direct; MUST be present if nameID is present)
        type: string
        example: idp3.acme.com 
      nameID:
        description: |
          The name ID from the SAML assertion when this user logged in (MAY be present only when grant_type is
          urn:talentappstore.com:oauth2:tas-direct; MUST be present if entityID is present)
        type: string
        example: idp3.acme.com 
      refresh_token:
        description: |
          A refresh token obtained via a previous call to this endpoint with scope of offline. MUST be present when grant_type is
          refresh_token. MUST NOT be present for other grant types.
        type: string
      parent_token:
        description: |
          An access token passed in to the consuming app. MUST be present when grant_type is urn:talentappstore.com:oauth2:tas-inherited.
          MUST NOT be present for other grant types.
        type: string
    responses:
      200:
        body:
          application/json:
            schema: !include ../schemas/tokenJwt.json
            example: !include ../examples/tokenJwt-simple.json

/patchSets:
  post:
    description: |
      This endpoint behaves exactly as per /tenants/{tenant}/patchSets, except that it creates a tenant rather than applying patches
      to an existing tenant.
  /{launchKey}:
    post:
      description: |
        This endpoint behaves exactly as per /tenants/{tenant}/patchSets/{launchKey}, except that it works against a tenant-creating patchSet,
        e.g. initial tenant creation, or copy, rather than a patchSet that is modifying an existing tenant.

                  
