#%RAML 0.8
---
title: TAS core incoming (app -> TAS)
baseUri: http://core.talentappstore.com/api/{version}
version: v1

traits: !include traits.yml

documentation:

 - title: Welcome
   content: |
    You're at the documentation for the Talent App Store (TAS) **core-in APIs**. See also the [core-out APIs](coreOut.raml.html)
    and the [index](../index.html) of all core API documentation, including RAML files, json schemas and API examples. 
    
    For a higher level view of TAS, and writing apps, go to the [developer site](http://developer.talentappstore.com).
    
 - title: About TAS APIs
   content: |
    TAS deals in two types of APIs.
    
    Core APIs are used by apps to talk to the core (i.e., core-in APIs) or vice versa (core-out APIs). The TAS core APIs are
    mainly used by apps to:
    - handle provisioning (when tenants install or uninstall your app) 
    - provide single sign on (SSO)
    - produce and consume tenant APIs (on other apps)
    
    Almost all core API calls are secured using [HMAC](../doc/HMAC.html).

    Tenant APIs are used by apps to talk to other apps on behalf of a tenant - for example, a job board fetching a list of 
    open jobs from an applicant tracking system (ATS) app.
    
    Tenant APIs are defined by developers, and not controlled in any way by TAS. However we do provide some best practice suggestion
    on how developers should [version tenant APIs](../doc/versioning.html).

/OAuthPublicKey:
  description: The *OAuth public key* is used by apps to verify that incoming OAuth tokens were indeed issued by TAS.
  get:
    description: Get the current public key used by TASA to sign OAuth tokens.
    responses:
      200:
        body:
          text/plain:
            example: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBoCtyhZycRSAQ5aqYMESTSAFr0lwIDAQAB

/patchSets:
  post:
    description: |
      This endpoint behaves exactly as per /tenants/{tenant}/patchSets, except that it creates a tenant rather than applying patches
      to an existing tenant.
      
      The core asserts that:
      - the app is marked as "storeFront"
      
  /{launchKey}:
    post:
      description: |
        This endpoint behaves exactly as per /tenants/{tenant}/patchSets/{launchKey}, except that it works against a tenant-creating patchSet,
        rather than a patchSet that is modifying an existing tenant.
        
        The core asserts that:
        - the app is marked as "storeFront"
                  
/ping:
  description: A ping is the simplest call an app can make against the TAS core
  get:
    description: Always return http 200. Useful for testing app is working OK (has correct secret key etc.).
    responses:
      200:

/routes:
  description: |
    About routes
    ------------
    Routes reflect a possible point to point API call between two apps on behalf of a tenant. They are usages:
    - of a tenant API
    - as produced in a specific way (source of truth or not)
    - by a consuming app 
    - installed at a tenant
    - on a producing app  (currently, always the same as the consuming tenant) 
    - installed at a tenant

    To consume a tenant API, the consuming app must first fetch a route in order to locate the actual endpoint (where the producer's
    server sits on the internet).
    
    Routes are also useful to the producer of an API, e.g. to validate the methods (POST, GET, etc.) that the consumer is allowed to call.

    Remote mounting
    ---------------
    Remote mounting is a possible future feature of TAS. It is not currently implemented.
 
    With remote mounting, apps can produce APIs (SoT or non-SoT) by remote mounting a specified tenant's SoT production of the same API.

    For example:
    - tenant acme has installed a number of job board apps
    - the tenant wants each job board app to produce (non-SoT) the /categories API
    - so that acme's other apps can query each job board's unique category setup, build mappings, etc.
    - the job board "green jobs" provides such a job board app
    - that app produces (non-SoT) /categories
    - however it does so by remote mounting the same API at the central green jobs tenant
    - inside the green jobs tenant, the app "corestuff" produces (SoT) the /categories API
    - therefore corestuff finishes up producing the API when consumed by some other app at the acme tenant 

    TAS detects and disallows loops.
    
  /{CT}:
    description: |
      Consuming tenant: the tenant with the app installed that is consuming the API
    /{CA}:
      description: |
        Consuming app: the app consuming the API
      get:
        is: [ routeFetcher ] 
        description: | 
          Used by tenant API consumers to fetch the route(s) from the consumer to each producer of a specific API.
           
          The core checks that:
          - the app making the core API call is the consuming app (i.e., matches {CA})
          - the consuming app is installed at {CT}
          - the consuming app has declared that it consumes the given API, in the given way (SoT or not).
        queryParameters:
          sot:
            type: boolean
            description: |
              True if the consuming app is consuming this as SoT (source of truth), otherwise false
            example: true
            required: true
        responses:
          200:
            body:
              application/json:
                schema: !include ../schemas/routes.json
                example: !include ../examples/routes-simple.json
      /{PT}:
        description: |
          Producing tenant: the tenant with the app installed that is producing the API
        /{PA}:
          description: |
            Producing app: the app producing the API
          get:
            is: [ routeFetcher ] 
            description: |
              Used by tenant API producers to verify that the consumer is allowed to consume this API.

              The core will assert that:
              - the app making the core API call is the producing app (i.e., matches {PA})
              - the producing app is installed at {PT}
              - the consuming app has declared that it consumes the given API
              - the producing app has declared that it produces the given API
              - the consuming app has declared that it consumes the given API in the same way that the producer has declared that it produces it (SoT or not).
                 
              Since both consuming and producing apps are specified, there can only be one or zero routes in the response.

            responses:
              200:
                body:
                  application/json:
                    schema: !include ../schemas/route.json
                    example: !include ../examples/route-simple.json

/samlIdPMetadata:
  description: |
    Apps that are SSO-protected (i.e., SPs in SAML lingo) require the SAML metadata for the TAS core proxy that acts as a facade in front of
    all of the identity providers that all of the tenants has set up. In other words there is a single unit of IdP metadata that can be used by all
    apps at all tenants.
     
  get:
    description: |
      description: Get the metadata for the IdP proxy.

      The core asserts that:
      - the app is linked to any principal type (i.e., it uses SSO)
          
    responses:
      200:
        body:
          application/xml:
              
/tenants:  
  description: |
    A *tenant* is a customer within the multi-tenanted environment of Talent App Store.
  get:
    description: |
      Get a list of shortCodes of every tenant that has this app installed.
    responses:
      200:
        body:
          application/json:
            schema: !include ../schemas/tenantList.json
            example: !include ../examples/tenantList-simple.json
  /{tenant}:
    get:
      description: |
        Get details of the tenant.
        
        The core asserts that:
        - the app is installed by the tenant
      responses:
        200:
          body:
            application/json:
              schema: !include ../schemas/tenant.json
              example: !include ../examples/tenant-simple.json
    /status:
      get:
        description: |
          Get the status of the tenant, including the current state and security generation. Normally apps would use this information
          when restarting to determine whether to flush cached OAuth tokens and routes.
          
          The core asserts that:
          - the app is installed by the tenant
           
        responses:
          200:
            body:
              application/json:
                schema: !include ../schemas/tenantStatus.json
                example: !include ../examples/tenantStatus-simple.json

    /saml:
      /assertions:
        /{PT}:
          description: The principal type of the SAML assertion.
          /{key}:
            get:
              description: |
                Fetch a SAML assertion via its database key.
            
                The core asserts that:
                - either the app is linked to the given principal type; or
                - the app produces (as SoT or not) at least one on-behalf API which is linked to the given principal type   
                - if found, the assertion has not expired (based on the stored assertion detail)
            
              responses:
                200:
                  body:
                    application/xml:
      /keyLookups:
        /{PT}:
          description: the principal type the assertion is for
          post:
            description: |
              Fetch the key of an incoming SAML assertion. Used by apps which include their own SAML SP layer (rather than sitting behind
              the proxy). TAS acts as a SAML proxy, and captures and stores assertions in an internal database, partitioned by principal type,
              prior to handing them off to the app (SP).

              The request body contains the content of the assertion to search for.
           
              The core asserts that:
              - the app making the call is linked to the given principal type
              - the assertion has not expired (based on the passed in assertion detail)
            body:
              application/xml:

    /samlSPMetadata:
      description: Apps that are SSO-protected (i.e., SPs in SAML lingo) require their own SAML metadata
      get:
        description: |
          Get the metadata for this app (the SP) as installed at this tenant.
          
          The core asserts that:
          - the app is linked to any principal type (i.e., it uses SSO)
          
        responses:
          200:
            body:
              application/xml:

    /rebootPrepares:
      description: |
        A reboot is the process of TAS performing an orderly shutdown and startup of all of the installed
        apps for a specific tenant whenever major changes are made to the tenant.

        The first step is to prepare the reboot using one of the rebootPrepares endpoints, which happens
        as a result of a tenant's actions in the storefront app's UI. Specifically;
        - when a tenant clicks "install" or "uninstall" on an app, the storefront app calls POST /tenants/{tenant}/rebootPrepares/patchSet,
        resulting in a reboot with [events like these](../examples/rebootStatus-juggleApps.json).
        - when a tenant clicks "reboot" on their tenant, the storefront app calls POST /tenants/{tenant}/rebootPrepares/noop,
        resulting in a reboot with [events like these](../examples/rebootStatus-simpleReboot.json).
        - when a tenant clicks "flush OAuth tokens" on their tenant, the storefront app calls POST /tenants/{tenant}/rebootPrepares/OAuthFlush,
        resulting in a reboot with [events like these](../examples/rebootStatus-bumpSecurityGeneration.json).

        The response body from any of the /rebootPrepares endpoints is an unguessable unique "launch key" which is then
        used with POST /tenants/{tenant}/reboots/{launchKey}.

        When any of the /rebootPrepares endpoints are called, the core asserts that the app is marked as "storeFront".
        
      /OAuthFlush:
        post:
          description: |
            A storefront app calls this endpoint to prepare a reboot that will increment the tenant's security generation.
            
            Called when a tenant admin person clicks "Flush tokens" in the storefront.

            This effectively invalidates all OAuth tokens for APIs consumed or produced by this tenant (since apps should
            always check for changed security generation). This is used by a tenant to mitigate an attack where the attacker
            has obtained an OAuth token.
            
          responses:
            200:
            
      /patchSet:
        post:
          description: |
            A storefront app calls this endpoint to prepare a reboot that will change the installed apps, e.g. to reflect the
            tenant clicking install on an app. The endpoint validates the attached patch document.

            Called when a tenant admin person clicks to install or uninstall apps in the storefront.
             
          body:
            application/json:
              schema: !include ../schemas/simplePatchSet.json
              example: !include ../examples/simplePatchSet-simple.json
          responses:
            200:
              body:
                application/json:
                  schema: !include ../schemas/patchSetLaunchKey.json
                  example: !include ../examples/patchSetLaunchKey-simple.json
      /noop:
        post:
          description: |
            A storefront app calls this endpoint to prepare a reboot that does nothing else.
            
            This provides a way to retry on failures that have locked up the tenant, e.g. a bad response from one of the orchestration APIs.

            Called when tenant admin person clicks "Reboot" in the storefront.
          responses:
            200:
      
    /reboots:
      description: |
        About reboots
        -------------
        A reboot is the process of TAS performing an orderly shutdown and startup of all of the installed
        apps for a specific tenant whenever major changes are made to the tenant.

        To play its part correctly when a reboot happens, your app's control server should produce the reboot APIs.
        TAS then consumes the following APIs during the reboot.
        - /tenants/{}/preHalts
        - /tenants/{}/halts
        - /tenants/{}/preStarts
        - /tenants/{}/starts

        As a reboot happens, TAS maintains a set of history events that the storefront app can
        use to feed a progress dialogue. 

        How the storefront launches a reboot
        ------------------------------------
        Once the storefront app has prepared a reboot by calling one of the POST /tenants/{tenant}/rebootPrepares endpoints,
        the the reboot does not start immediately. Instead, the APIs return a launch key.

        To actually start a reboot, the storefront app (typically from within a web page's
        onClick handler of a "Continue" button) uses this launch key to launch the reboot.

        As a reboot happens, TAS maintains the event history, and also a status for;
        - the tenant as a whole (see [tenant statuses](../schemas/tenantStatus.json))
        - each individual app

        Order of events during reboot
        -----------------------------
        During a reboot, the order of events is:

        - Halt all apps
          - TAS sets the tenant's status to "preHalting"
          - TAS calls /tenants/{}/preHalts on each installed app
          - When the last app returns 200, TAS sets the tenant's status to "preHalted"
          - TAS sets the tenant's status to "halting"
          - TAS calls /tenants/{}/halts on each installed app
          - When the last app returns 200, TAS sets the tenant's status to "halted"

        - TAS increments tenant.incarnation
        - TAS performs the actual operation, i.e.:
          - do nothing (if this reboot is in response to a call to POST /tenants/{}/reboots)
          - apply the patch set, e.g. to install an app (if this reboot is in response to a call to POST /tenants/{}/patchSets)
            - apps are installed or uninstalled
            - routes are adjusted
          - increment tenant.securityGeneration
            - explicitly (if this reboot is in response to a call to POST /tenants/{}/OAuthFlushes, i.e. the tenant clicked "Flush OAuth tokens"); or
            - implicitly (if this reboot is in response to a call to POST /tenants/{}/patchSets and
            TAS finds that the patch set is making changes to the tenant's idps or assertion hooks)
        - Start all apps
          - TAS sets the tenant's status to "preStarting"
          - TAS calls /tenants/{}/preStarts on each installed app
          - When the last app returns 200, TAS sets the tenant's status to "preStarted"
          - TAS sets the tenant's status to "starting"
          - TAS calls /tenants/{}/starts on each installed app
          - When the last app returns 200, TAS sets the tenant's status to "starting"
                      
      /{launchKey}:
        post:
          description: |
            A storefront app's web page uses this API to launch a previously prepared reboot (if not already launched),
            and get the latest events and the current summary details.
            
            This endpoint is unauthenticated and has CORS headers that allow access from any domain (since the javascript calling it
            belongs to a storefront app which does not share the same domain as the tas core).
            
            If the apply is already "complete" then this call will return immediately, with any events that match the filter,
            up to the maximum events per call (100).
            
            Otherwise, the call blocks for .5 seconds to avoid thrashing, then returns as soon as at least one event is
            available that matches the filter, or the apply becomes complete (which would always be accompanied by an event).
            If no events are available after 60 seconds, the call returns indicating a timeout - the client will typically
            immediately make another call in a typical long-polling pattern, until the apply is marked as complete and the
            last event has been fetched.
            
          queryParameters:
            afterEvent:
              type: integer
              description: |
                The sequence of an existing event - this call should return events immediately *after* this event.
                Omitting this parameter returns the first events.
              example: 12
              required: false
          responses:
            200:
              body:
                application/json:
                  schema: !include ../schemas/rebootStatus.json
                  example: !include ../examples/rebootStatus-juggleApps.json
                            
/token:
  description: |
    About OAuth tokens
    ------------------
    API calls between apps (i.e. tenant API calls) are protected by OAuth access tokens, with TAS acting as the authorization server.

    An OAuth token in TAS has [this structure](../schemas/tokenJwt.json). An example token is [shown here](../examples/tokenJwt-simple.json).

    A single OAuth token is scoped by the combination of consumer and producer app, and can be used to consume any allowable method on
    any allowable API between the two. Currently, the consumer and producer will always be at the same tenant.

    The flow for consuming a tenant API is as follows;
    - The app consuming the API (the consumer) calls GET /routes to locate the actual endpoint (the producer)
    - The consumer checks its cache to see if it already has an OAuth token for the combination of consumer and producer
    - If not, it calls POST /token to obtain an OAuth token from the TAS core
    - The consumer makes the API call, passing the token in the Authorization header
    - The producer checks that the token is valid and being used correctly
    - For on-behalf tokens, the producer extracts the logs in user's identity
    - The producer produces the API

    Rather than being passed as raw json, OAuth tokens are passed as a JWT (json web token; see http://jwt.io/). Because JWTs are self-contained
    and signed, producers can rely on their content without any network traffic to the authorization server (i.e. TAS core).
    
    For more background on OAuth and tokens, see the [OAuth 2 spec(http://tools.ietf.org/html/rfc6749') and also Google's
    [OAuth documentation](https://developers.google.com/accounts/docs/OAuth2WebServer) for additional context.

    
    On-behalf tokens
    ----------------
    OAuth tokens may further be on-behalf, i.e. principal-aware, in which case they also identify some ultimate logged in end user
    who the API call is on behalf of, in the "sub" field. 


    Refresh tokens
    --------------
    Some apps need to continue making API calls on behalf of a user, even when the user is no longer logged in.
    
    Any app that is protected via TAS SSO and is marked as "offlineCapable" (TODO:
    exact name) can use the urn:ietf:params:oauth:client-assertion-type:saml2-bearer
    grant type (which requires a SAML assertion), and add the string "offline" to the scope
    parameter in the call to POST /token to create both an on-behalf OAuth access token and an accompanying refresh token.
    Your app should store the refresh token in its own long-term storage, and can use the access token immediately.
    
    The access token can be used immediately, and when it expires, the refresh token can be used to generate new
    access tokens even when the user is no longer logged in.
    
    Note: you only need to use refresh tokens if the offline activity is on behalf of a specific user. Otherwise
    your app can just use the client_credentials grant type to request a new OAuth token as soon as the existing one expires.

    Example:
        
    ````
    POST /oauth2/v1/token HTTP/1.1
    Host: core.talentappstore.com
    Content-Type: application/x-www-form-urlencoded

    grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-bearer
    scope=/acme/jobboard/acme/ats%20offline
    principal_type=candidate
    assertion=kjh9786gJHGutvfUT765Kkjghf70978klhjhgIUYGkpoiygEciYnjOi...
    Response:
    {
      "access_token":"iuhy76YT785L0GDF23JH7kjhd",
      "expires_in":3600,
      "token_type":"Bearer",
      "refresh_token":"j089777bhkltyHTRFG78969KJH968d"
    }
    ````
    
    Internally, TAS stores a copy of refresh tokens that it has issued, so it can validate
    requests for new access tokens. These refresh tokens are stored keyed by:
    - principal type
    - saml key (i.e. a key for the specific SAML assertion that was passed in the "assertion" parameter 
    user identifier (/E/N)
    - the SSO-protected app the user logged into (the API consuming app in this case)
    - consuming app install
    - producing app install
    
    Your app should save refresh tokens in long-term storage and continue to use them as long as they
    remain valid. If your app requests another refresh token for the same combination of
    values above, a new refresh token will be issued and any previous refresh token will be revoked.
    
    There is currently no support for refresh token revocation as per https://tools.ietf.org/html/rfc7009.

    Verifying incoming OAuth tokens
    -------------------------------
    To be secure, when an app receives an incoming tenant API call, it must:
    - Check that an incoming OAuth token was provided in the Authorization request header
    - Verify that the OAuth token was correctly signed by TAS core, and matches the public key from GET /OAuthKey.
    - Check that the token has not expired (exp field)
    - Check that it is the correct audience (to prevent a malicious app using a token for your app which was intended for another app), i.e.;
      - the "pt" (producing tenant) field matches the current tenant (e.g. as extracted from the Host header)
      - the "pa" (producing app) field matches the shortCode hard-coded into the app's code
    - call GET /routes/{CT}/{CA}/{PT}/{PA} to verify that a route exists (to prevent a malicious app calling an API on your app which it has not declared that it calls)
    - check that whatever method is being used (GET, POST, etc.) is one of the supported methods declare on the API itself 

    Because performing the checks above involves making TAS core API calls, the producing app should attempt to cache the results whenever possible.

    For intra-tenant calls (i.e., where the producer and the consumer are the same), the
    producer can cache route verifications as long as the "sgen" (security generation) parameter
    in the token matches the app's own stored value for sgen.

    This works because sgen cannot be changed without bouncing the tenant, and every app is always
    informed when the tenant is bounced, so the producer always knows it has the latest value for
    sgen.

    A typical cache implementation might:
    - store verification outcomes for intra-tenant calls as booleans in a key value store
    - key the outcomes by some synthesised string like /routes/acme/uberapply/acme/ats/tas/%2Fcategories/GET
    - flush the cache whenever sgen changes

    For inter-tenant calls (i.e. where the consumer is a remote app likely installed at another tenant),
    the producer does not receive any notifications when the remote tenant is bounced. Therefore it
    has no way to maintain an up to date copy of the remote tenant's sgen value. This means that the producer
    must verify the route every time. This is not an issue until when/if TAS supports remote mounting.

  post:
    description: |
      Get a new access token, and optionally a refresh token.

      The request body must be of content-type application/x-www-form-urlencoded, and contain values for grant_type
      and optionally other parameters, encoded as per https://tools.ietf.org/html/rfc6749#appendix-B.
      See also https://tools.ietf.org/html/rfc7522#section-4.

      The core asserts that:
      - the consuming app is installed at the consuming tenant
      - the producing app is installed at the producing tenant
      - there exists at least one route between the consumer and producer, for any API (this prevents malicious apps probing for
      the presence of other apps)
        
      Every call to this endpoint results in a new access token being issued, with an expiry time set to one hour, or
      (as per http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithSAML.html) to the time specified in the SAML
      assertion's SessionNotOnOrAfter value (if present), whichever is shorter.
    
      If SessionNotOnOrAfter is in the past then token creation fails, and the app must somehow force the user to reauthenticate.
    
      For efficiency consumers should cache the tokens returned by this endpoint until (a) the tenant's security generation
      number changes, or (b) the cached token is too close to expiry to serve the needs of the consumer.

    body:
      application/x-www-form-urlencoded:
        formParameters:
          grant_type:
            description: |
               One of:
               - **client_credentials**: for an anonymous OAuth tokens that is not on behalf of any user/principal.
               Anonymous tokens are easy to create, but can't be used to consume on-behalf APIs, which tend to be those
               with principal-specific logic or security, e.g. only allowing users in the finance department to view
               account details, logging who the user was who created a job, etc. Anonymous access tokens always expire
               one hour after they are issued.
               - **urn:ietf:params:oauth:client-assertion-type:saml2-bearer**: for an on-behalf OAuth token that includes the identity
               of the user/principal who is the subject of the passed in SAML assertion. This grant type can only be used by apps that
               are protected via SSO. The token's expiry time will be either in one hour, or at the time dictated by the original SAML
                assertion's "SessionNotOnOrAfter" field, whichever is sooner.
               - **urn:talentappstore.com:oauth:saml2-bearer-key**: As for urn:ietf:params:oauth:client-assertion-type:saml2-bearer, except
               that the key is used rather than the assertion itself.
               - **urn:talentappstore.com:oauth:tas-inherited**: for an on-behalf token that re-uses the user's identity from an incoming
               on-behalf token. Used by apps that both produce and consume on-behalf APIs; i.e. apps that are intermediate links in a chain
               of on-behalf API calls. The new access token inherits details of the principal (if any) and the expiry time 
               from the parent access token. This means all access tokens created as part of a nested set
               of API calls will expire simultaneously.
               - **refresh_token**: for an on-behalf token derived from a refresh token obtained previously via a call to the
               token endpoint with scope of "offline". The access token has a life of one hour. 
            type: string
            example: urn:talentappstore.com:oauth:saml2-bearer-key
          scope:
            description: |
              A space separated set of values for the OAuth scope of this token, which may include: 
              - A string starting with "/" that denotes a consuming app installed at a specific tenant
              and a producing app installed at a specific tenant (MUST be present for all grant types other than refresh_token)
              - the keyword "offline" (MAY be present only when grant_type is urn:ietf:params:oauth:client-assertion-type:saml2-bearer)
            type: string
            example: /acme/jobboard/acme/ats offline 
          principal_type:
            description: |
              The principal type the on-behalf token is being created for. MUST be present when grant_type is
              urn:ietf:params:oauth:client-assertion-type:saml2-bearer or
              urn:talentappstore.com:oauth:saml2-bearer-key. MUST NOT be present for other grant types.
            type: string
            example: candidate 
          refresh_token:
            description: |
              A refresh token obtained via a previous call to this endpoint with scope of offline. MUST be present when grant_type is
              refresh_token. MUST NOT be present for other grant types.
            type: string
          parent_token:
            description: |
              An access token passed in to the consuming app. MUST be present when grant_type is urn:talentappstore.com:oauth2:tas-inherited.
              MUST NOT be present for other grant types.
            type: string
          assertion:
            description: |
              The incoming SAML assertion. MUST be present for grant_type of urn:ietf:params:oauth:client-assertion-type:saml2-bearer.
              MUST NOT be present for other grant types. MUST contain an unexpired SAML assertion that matches exactly one as captured
              and stored by the TAS SAML proxy during login to *this app*.
          samlKey:
            description: |
              A reference to the incoming SAML assertion. MUST be present for grant_type of urn:talentappstore.com:oauth:saml2-bearer-ref.
              MUST NOT be present for other grant types. MUST contain a valid reference to an unexpired SAML assertion as captured
              and stored by the TAS SAML proxy during login *to this app*.
    responses:
      200:
        body:
          application/json:
            schema: !include ../schemas/tokenResponse.json
            example: !include ../examples/tokenResponse-simple.json

