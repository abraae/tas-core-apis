#%RAML 0.8
---
title: TAS core incoming (app -> TAS)
baseUri: http://talentappstore.com/{version}
version: v1

/{tenant}:
  description: |
    <p>A <b>tenant</b> is a customer within the multi-tenanted environment of Talent App Store.</p>
    <p>All core API calls that your app makes to TAS are within the context of a single tenant. TAS
    does not support API calls between tenants.</p>
  get:
    description: |
      Get information about the tenant, including the current status, incarnation and public key. Normally apps would get the
      incarnation in the request body of the startUp event, so this is mainly useful if your app is restarted, and needs
      to check what's been going on while its been offline.
    responses:
      200:
        body:
          application/json:
            schema: !include ../schemas/tenant.json
            example: !include ../examples/tenant.json
  /samlMetadata:
    description: |
      SAML metadata is a package of XML information about identity providers, certificates, etc., that your app's SSO
      implementation needs to do its thing (assuming your app is a web server, rather than an API server).
    /{principalDeveloper}:
      /{principalType}:
        get:
          description: |
            Get the SAML metadata for the given principal type. This is only callable by web servers (not API servers). TAS
            will validate that the app is entitled to use the principal type for authentication.
          responses:
            200:
              body:
                application/xml:
  /samlSubjects:
    description: |
      <p>A samlSubject is the primary key, controlled by the IdP, of the current logged in user. A samlSubject is useful
      when your app wants to get some more detail about the user such as their name, email, etc, by calling SCIM APIs
      like /employees/{samlSubject}, etc. - these APIs require a samlSubject.</p>
      <p>By "current logged in user", we mean someone logged into this app (if this app is an SSO-protected app) or another app
      higher up the chain (if this app is an API server producing an OAuth API).</p>
      <p>samlSubject is a string made up of values extracted from the SAML authentication assertion information that
      was captured by TAS when this user logged in to an SSO-protected app, likely to include: 
      <ul>
      <li>NameID</li>
      <li>NameQualifier</li>
      <li>EntityID of the issuing IdP</li>
      </ul>
      <p>The actual SAML items above are not yet confirmed, nor do we have a any standard approach to requesting them in SAML assertions
      or extracting them from SAML assertions. But in any case the set will uniquely identify the user, even across
      multiple possible authenticating IdPs. For example, "candidates" may be held across a number of IdPs, including corporate IdP
      (internal candidates), Facebook pseudo-IdP, etc.</p>
      <p>samlSubjects are identical across all SP's (i.e., all TAS SSO-protected apps), so that apps can
      correlate the user's identity (i.e. they each have the same understanding of who a user is). This means that transient SAML
      identifiers for example cannot be used.
      </p>
      <p>API servers can extract the samlSubject from the sub field of the incoming OAuth access token.</p>
      <p>Because access tokens are generated and signed by TAS, the user's identity can be passed securely down through a chain of
      OAuth API calls, while preventing malicious apps from acting on behalf of a user who has not logged in.</p>
      <p>Each producing app in the chain gets their chance to enforce their own business rules and make further
      tenant API calls on behalf of the logged in user.</p>     
    /viaSamlAssertion:
      post:
        description: |
          If your app is an SSO-protected web site, then it can exchange the SAML authentication assertion that it received at
          login time for the samlSubject by using this endpoint and passing the assertion as the request body.
        body:
          application/xml:
        responses:
          200:
            body:
              application/json:
                schema: !include ../schemas/samlSubject.json
                example: !include ../examples/samlSubject.json
  /routes:
    description: |
      <p>Routes are usages of a specific tenant API, on a specific producing app, by a specific consuming app.</p>
      <p>Your app needs to first fetch a route in order to consume an API. The route will tell your app:
      <ul>
      <li>The actual endpoint (where the producer's server sits on the internet)</li>
      <li>For non-OAuth APIs, whether the producer is using HMAC or basic auth, and the actual credentials themselves.</li>
      </ul>
      </p>
      <p>Routes are also useful to the producer of an API, e.g. to validate the methods (POST, GET, etc.)
      that the consumer is allowed to call.</p>
      <p>For SoT APIs, there can be only one producing app, and hence only one route per consumer; for non-SoT
      APIs, there can be many consumers and many producers, and hence a route between each unique
      consumer/producer pair.</p>
    /{consumingApp}:
      description: |
        The app consuming the API
      /{apiDeveloper}:
        description: The developer who owns/defines the API
        /{apiUriTemplate}:
          description: The URI template (as per https://tools.ietf.org/html/rfc6570) of the API.
          get:
            description: | 
              Fetch the route(s), from the consumer (which must be your app), to each producer of a specific API.
              The example below is for a non-OAuth, non-SoT API.
            responses:
              200:
                body:
                  application/json:
                    schema: !include ../schemas/routes.json
                    example: !include ../examples/routes.json
          /{producer}:
            get:
              description: | 
                Fetch the route, from the given consumer, to the producer (which must be your app)
                of a specific API. Since both consuming and producing apps are specified, there can only be
                one or zero routes in the response.
              responses:
                200:
                  body:
                    application/json:
                      schema: !include ../schemas/route.json
                      example: !include ../examples/route.json
            /tokens:
              description: |
                <p>OAuth tokens are self-contained security tokens in the form of a JWT (json web token; see
                http://www.intridea.com/blog/2013/11/7/json-web-token-the-useful-little-standard-you-haven-t-heard-about
                and http://jwt.io/):
                a) that authorizes a specific consuming app to consume a specific OAuth tenant API at a specific producing app.</p>
                <p>Because access tokens are self-contained and signed, producers can rely on their content without any network
                traffic to the authorization server (i.e. TAS).</p>
                <p>Every call to this endpoint results in a new token being issued, with an expiry time set to either one hour, or
                (as per http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithSAML.html) to the time specified in the SAML
                assertion's SessionNotOnOrAfter value (if present), whichever is shorter.</p>
                <p>If SessionNotOnOrAfter is in the past then token creation fails, and the app must somehow force the user to reauthenticate.
                For efficiency consumers should cache the tokens returned by this endpoint until (a) the app is restarted, or (b) the cached token
                is too close to expiry to serve the needs of the consumer.</p>
              /viaSso:
                /{principalAuthnID}:
                  description: |
                    The id of the current authentication, as passed to your app's SSO-protected web site (see details of authentication).
                  post:
                    description: |
                      Called by your app to obtain an OAuth token to consume the API of the given route, for the given principal.
                    responses:
                      200:
                        body:
                          application/json:
                            schema: !include ../schemas/tokenJwt.json
                            example: !include ../examples/tokenJwt.json
              /viaToken:
                /{accessToken}:
                  description: |
                    <p>The OAuth access token (a JWT) passed in to the producing app, which has:
                    <ul>
                    <li>the producing app as the "aud" field</li>
                    <li>the principal via its "sub" field</li>
                    </ul>
                    </p>
                    <p>New tokens generated form this endpoint have no relationship to their ancestor tokens - e.g.,
                    if the ancestor token expires, that does not tokens created from it.</p>
                  post:
                    description:
                      Called by your app to obtain an OAuth token to consume the API of the given route, for the given principal.
                    responses:
                      200:
                        body:
                          application/json:
                            schema: !include ../schemas/tokenJwt.json
                            example: !include ../examples/tokenJwt.json
  /deltaSets:
    post:
      description: |
        <p>A delta set is a set of deltas to apply to the tenant's current installed apps, e.g. as the result of
        a tenant clicking install on some app. Each item in the set is one of the
        following operations relating to an app:
        <ol>
        <li>install (the app must be either listed in the TAS directory, or shared with the tenant).</li>
        <li>edit</li>
        <li>unInstall</li>
        </ol>
        </p>
        <p>To apply the set, TAS does the following:
        <ol>
        <li>requests each already installed app to shut down</li>
        <li>waits until each app has signalled a successful shutdown</li>
        <li>applies the set</li>
        <li>resets all volatile credentials for the tenant:
        <ul>
        <li>The tenant's own private/public key pair (as obtained via GET /{tenant})
        <li>All HMAC signing keys (as held on routes)
        </ul>
        <li>Increments the tenant's incarnation (thus invalidating all existing OAuth tokens)
        <li>detects whether the delta set includes uninstalling the app the user is currently on, and if
        so calls GET /m/storeFrontMainPage to guess the startup page.   
        <li>sends startup requests to each installed app</li>
        </ol>
        </p>
        <p>Calling this API does not apply the delta set, but instead prepares a launcher, which is a self-contained
        JWT (json web token) signed with the tenant's signing key that embeds the delta set and can be safely handed
        off to an insecure client, i.e. javascript in a web browser.</p>
        <p>The insecure client can then, via unauthenticated CORS calls, use the launcher
        to start the operation and subsequently track its progress, e.g. via a progress dialog.</p>
        <p>This technique allows the storefront app to keep this part of its user interface working
        even while the storefront app itself (like
        all other installed apps) is cycled down and up as part of the operation.</p>
        <p>Since successfully applying a delta set (even an empty one) changes the tenant's signing key and
        increments incarnation, it will also invalidate any outstanding launchers. Launchers also expire within
        10 minutes of being issued. Launchers are meant to be used immediately.</p>
        <p>An empty deltas set can be passed as a way to reboot the tenant, i.e. take down and then bring up all apps.
        Because this increments the tenant's incarnation, and therefore invalidates all existing OAuth tokens and HMAC
        signing keys, this is an appropriate action to take in the event of a compromise of a token or signing key.
        Note: the schema and example do not show the JWT-specific fields, including the "exp" field which is set to
        10 minutes in the future.
        </p>
      body:
        application/json:
          schema: !include ../schemas/deltaSet.json
          example: !include ../examples/deltaSet.json
      responses:
        200:
          body:
            application/json:
              schema: !include ../schemas/deltaSet.json
              example: !include ../examples/deltaSet.json
  /deltaSetLaunchers:
    post:
      description: |
        <p>Launch the delta set as contained in the launcher JWT passed as the request body (and prepared by an earlier server-side
        call to POST /deltaSets). The launcher JWT is signed using the tenant's signing key.</p>
        <p>This endpoint is unauthenticated and has CORS headers that allow access from any domain (since the javascript calling it
        belongs to the storefront app which does not share the same domain as the tas core).</p>
        <p>The response body is a deltaSetStatus structure, containing zero or more events and summary status of the
        delta apply operation. Since the operation is long-running, and will likely not be complete when the endpoint returns,
        the deltaSetStatus also includes an unguessable unique "launch key" which can be passed as a parameter to
        GET /deltaSetLaunches (not launch-ers), a long polling call, intended for use by Javascript inside a storefront
        app, to get up to 100 events relating to an apply operation, along with summary information.</p>
      body:
        application/json:
          schema: !include ../schemas/deltaSet.json
          example: !include ../examples/deltaSet.json
      responses:
        200:
          body:
            application/json:
              schema: !include ../schemas/deltaSetStatus.json
              example: !include ../examples/deltaSetStatus.json
  /deltaSetLaunches:
    /{launchKey}:
      get:
        description: |
          <p>Get the latest events and the current summary details about a previous launch of a delta set apply.</p>
          <p>If the apply is already "complete" then this call will return immediately, with any events that match the filter,
          up to the maximum events per call.</p>
          <p>Otherwise, the call blocks for .5 seconds to avoid thrashing, then returns as soon as at least one event is
          available that matches the filter, or the apply becomes complete (which would always be acocmpanied by an event).
          If no events are available after 60 seconds, the call returns indicating a timeout - the client will typically
          immediately make another call in a typical long-polling pattern, until the apply is marked as complete and the
          last event has been fetched.</p>
        queryParameters:
          afterEvent:
            displayName: After Event
            type: integer
            description: |
              The sequence of an existing event - this call should return events immediately *after* this event.
              Omitting this parameter returns the first events.
            example: 12
            required: false
        responses:
          200:
            body:
              application/json:
                schema: !include ../schemas/deltaSetStatus.json
                example: !include ../examples/deltaSetStatus.json
  /installs:
    description: Installs are currently installed apps at the tenant.
    /{app}:
      description: An app
      get:
        description: |
          Called by a storefront app to get details about an already installed app, e.g. to obtain the server basic auth info.
        responses:
          200:
            body:
              application/json:
      /shutDownCompletions:
        description: |
          A shutDownCompletion represents an app's completion of its shutdown processing, which it should achieve within a few seconds of
          receiving a call from TAS to POST /{tenant}/shutDowns. 
        /{shutDownCompletionKey}:
          description: The unguessable key passed by TAS in its call to POST /{tenant}/shutDowns