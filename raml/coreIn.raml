#%RAML 0.8
---
title: TAS core incoming (app -> TAS)
baseUri: http://core.talentappstore.com/api/{version}
version: v1

traits: !include traits.yml

documentation:

 - title: Welcome
   content: |
    You're at the core API documentation for Talent App Store. If you'ld like a higher level view, go to the
    [developer site](http://developer.talentappstore.com).

 - title: HMAC
   content: |
    Most core API calls are secured using the same HMAC approach as
    <a href='http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html'>Amazon Web Service's Signature Version 4 signing process</a>,
     see also http://security.stackexchange.com/questions/77372/unusual-design-aspects-of-aws-hmac-based-authentication-v4),
    except that whereas an AWS signature key
    is generated like this (see http://docs.aws.amazon.com/general/latest/gr/signature-v4-examples.html)...

    ````
    static byte[] getSignatureKey(String key, String dateStamp, String regionName, String serviceName) throws Exception  {
         byte[] kSecret = ("AWS4" + key).getBytes("UTF8");
         byte[] kDate    = HmacSHA256(dateStamp, kSecret);
         byte[] kRegion  = HmacSHA256(regionName, kDate);
         byte[] kService = HmacSHA256(serviceName, kRegion);
         byte[] kSigning = HmacSHA256("aws4_request", kService);
         return kSigning;
    }
    ````
    
    A TAS signature key for a core API call (in or out) is generated like this...
    
    ````
    static byte[] getSignatureKey(String key, String dateStamp) throws Exception  {
         byte[] kSecret = ("TAS4" + key).getBytes("UTF8");
         byte[] kDate    = HmacSHA256(dateStamp, kSecret);
         byte[] kSigning = HmacSHA256("tas4_request", kService);
         return kSigning;
    }
    ````
    
/apps:
  description: An *app* is a microservice that can be installed by a tenant
  /{app}:
    get:
      description: |
        Get details of the app. This is useful when some piece of software (like a proxy) is acting on behalf of the app,
        but has only been given its shortCode and secret key.
        
        The core asserts that:
        - the call is being made by the app itself
        
      responses:
        200:
          body:
            application/json:
              schema: !include ../schemas/app.json
              example: !include ../examples/app-simple.json

/OAuthKey:
  description: The *OAuth public key* is used by apps to verify that incoming OAuth tokens were indeed issued by TAS.
  get:
    description: Get the current public key used by TASA to sign OAuth tokens.
    responses:
      200:
        body:
          text/plain:
            example: kuh9876guhgfyr76453dytrfUTYGuytfUrt

/patchSets:
  post:
    description: |
      This endpoint behaves exactly as per /tenants/{tenant}/patchSets, except that it creates a tenant rather than applying patches
      to an existing tenant.
      
      The core asserts that:
      - the app is marked as "storeFront"
      
  /{launchKey}:
    post:
      description: |
        This endpoint behaves exactly as per /tenants/{tenant}/patchSets/{launchKey}, except that it works against a tenant-creating patchSet,
        rather than a patchSet that is modifying an existing tenant.
        
        The core asserts that:
        - the app is marked as "storeFront"
                  
/ping:
  description: A ping is the simplest call an app can make against the TAS core
  get:
    description: Always return http 200. Useful for testing app is working OK (has correct secret key etc.).
    responses:
      200:

/routes:
  description: |
    About routes
    ------------
    Routes reflect a possible point to point API call between two apps on behalf of a tenant. They are usages:
    - of a tenant API
    - as produced in a specific way (source of truth or not)
    - by a consuming app 
    - installed at a tenant
    - on a producing app  (currently, always the same as the consuming tenant) 
    - installed at a tenant

    To consume a tenant API, the consuming app must first fetch a route in order to locate the actual endpoint (where the producer's
    server sits on the internet).
    
    Routes are also useful to the producer of an API, e.g. to validate the methods (POST, GET, etc.) that the consumer is allowed to call.

    Remote mounting
    ---------------
    Remote mounting is a possible future feature of TAS. It is not currently implemented.
 
    With remote mounting, apps can produce APIs (SoT or non-SoT) by remote mounting a specified tenant's SoT production of the same API.

    For example:
    - tenant acme has installed a number of job board apps
    - the tenant wants each job board app to produce (non-SoT) the /categories API
    - so that acme's other apps can query each job board's unique category setup, build mappings, etc.
    - the job board "green jobs" provides such a job board app
    - that app produces (non-SoT) /categories
    - however it does so by remote mounting the same API at the central green jobs tenant
    - inside the green jobs tenant, the app "corestuff" produces (SoT) the /categories API
    - therefore corestuff finishes up producing the API when consumed by some other app at the acme tenant 

    TAS detects and disallows loops.
    
  /{CT}:
    description: |
      Consuming tenant: the tenant with the app installed that is consuming the API
    /{CA}:
      description: |
        Consuming app: the app consuming the API
      get:
        is: [ routeFetcher ] 
        description: | 
          Used by tenant API consumers to fetch the route(s) from the consumer to each producer of a specific API.
           
          The core checks that:
          - the app making the core API call is the consuming app (i.e., matches {CA})
          - the consuming app is installed at {CT}
          - the consuming app has declared that it consumes the given API, in the given way (SoT or not).
        queryParameters:
          sot:
            type: boolean
            description: |
              True if the consuming app is consuming this as SoT (source of truth), otherwise false
            example: true
            required: true
        responses:
          200:
            body:
              application/json:
                schema: !include ../schemas/routes.json
                example: !include ../examples/routes-simple.json
      /{PT}:
        description: |
          Producing tenant: the tenant with the app installed that is producing the API
        /{PA}:
          description: |
            Producing app: the app producing the API
          get:
            is: [ routeFetcher ] 
            description: |
              Used by tenant API producers to verify that the consumer is allowed to consume this API.

              The core will assert that:
              - the app making the core API call is the producing app (i.e., matches {PA})
              - the producing app is installed at {PT}
              - the consuming app has declared that it consumes the given API
              - the producing app has declared that it produces the given API
              - the consuming app has declared that it consumes the given API in the same way that the producer has declared that it produces it (SoT or not).
                 
              Since both consuming and producing apps are specified, there can only be one or zero routes in the response.

            responses:
              200:
                body:
                  application/json:
                    schema: !include ../schemas/route.json
                    example: !include ../examples/route-simple.json

/saml:
  /assertions:
    /{PT}:
      description: The principal type of the SAML assertion.
      /{key}:
        get:
          description: |
            Fetch a SAML assertion via its database key.
            
            The core asserts that:
            - either the app is linked to the given principal type; or
            - the app produces (as SoT or not) at least one on-behalf API which is linked to the given principal type   
            - if found, the assertion has not expired (based on the stored assertion detail)
            
          responses:
            200:
              body:
                application/xml:
  /keyLookups:
    /{PT}:
      description: the principal type the assertion is for
      post:
        description: |
          Fetch the key of an incoming SAML assertion. Used by apps which include their own SAML SP layer (rather than sitting behind
          the proxy). TAS acts as a SAML proxy, and captures and stores assertions in an internal database, partitioned by principal type,
          prior to handing them off to the app (SP).

          The request body contains the content of the assertion to search for.
           
          The core asserts that:
          - the app making the call is linked to the given principal type
          - the assertion has not expired (based on the passed in assertion detail)
        body:
          application/xml:
              
/tenants:  
  description: |
    A *tenant* is a customer within the multi-tenanted environment of Talent App Store.
  /{tenant}:
    get:
      description: |
        Get details of the tenant.
        
        The core asserts that:
        - the app is installed by the tenant
      responses:
        200:
          body:
            application/json:
              schema: !include ../schemas/tenant.json
              example: !include ../examples/tenant-simple.json
    /status:
      get:
        description: |
          Get the status of the tenant, including the current state and security generation. Normally apps would use this information
          when restarting to determine whether to flush cached OAuth tokens and routes.
          
          The core asserts that:
          - the app is installed by the tenant
           
        responses:
          200:
            body:
              application/json:
                schema: !include ../schemas/tenantStatus.json
                example: !include ../examples/tenantStatus-simple.json

    /samlSPMetadata:
      description: Apps that are SSO-protected (i.e., SPs in SAML lingo) require their own SAML metadata
      get:
        description: |
          Get the metadata for this app (the SP).
          
          The core asserts that:
          - the app is linked to any principal type (i.e., it uses SSO)
          
        responses:
          200:
            body:
              application/xml:

    /samlIdPMetadata:
      description: |
        Apps that are SSO-protected (i.e., SPs in SAML lingo) require the SAML metadata for the IdP proxy that front ends all of the
        identity providers that the tenant has set up.
      get:
        description: |
          description: Get the metadata for the IdP proxy.
          
          The core asserts that:
          - the app is linked to any principal type (i.e., it uses SSO)
          
        responses:
          200:
            body:
              application/xml:

    /OAuthFlushes:
      post:
        description: |
          A storefront app calls this endpoint to reboot the tenant and increment the security generation. This effectively
          (since apps should always check for changed security generation) invalidates all OAuth tokens for
          APIs consumed or produced by this tenant. This is used to mitigate an attack where an app has an OAuth token
          stolen from it (tenant admin person clicks "Flush credentials" in the storefront).
          
          The response body is an unguessable unique "launch key" which is then used with POST /tenants/{tenant}/reboots/{launchKey}.
           
          The core asserts that:
          - the app is marked as "storeFront".
        body:
          application/json:
            schema: !include ../schemas/patchSetPreparer.json
            example: !include ../examples/patchSetPreparer-installApp.json
        responses:
          200:
            body:
              application/json:
                schema: !include ../schemas/patchSetLaunchKey.json
                example: !include ../examples/patchSetLaunchKey-simple.json
    /patchSets:
      post:
        description: |
          A storefront app calls this endpoint to validate and then prepare a patch document, e.g. to reflect the tenant clicking install on an app.
          
          The response body is an unguessable unique "launch key" which can be used with POST /tenants/{tenant}/reboots/{launchKey}.
          
          Pass true for "bumpSecurityGeneration" to force the security generation to be incremented.
           
          The core asserts that:
          - the app is marked as "storeFront".
        body:
          application/json:
            schema: !include ../schemas/patchSetPreparer.json
            example: !include ../examples/patchSetPreparer-installApp.json
        responses:
          200:
            body:
              application/json:
                schema: !include ../schemas/patchSetLaunchKey.json
                example: !include ../examples/patchSetLaunchKey-simple.json
    /reboots:
      description: |
        About reboots
        -------------
        A reboot is the process of TAS performing an orderly shutdown and startup of all of the installed
        apps for a specific tenant whenever major changes are made to the tenant.

        To play its part correctly when a reboot happens, your app's control server should produce the reboot APIs.
        TAS then consumes the following APIs during the reboot.
        - /tenants/{}/preHalts
        - /tenants/{}/halts
        - /tenants/{}/preStarts
        - /tenants/{}/starts

        As a reboot happens, TAS maintains a set of history events that the storefront app can
        use to feed a progress dialogue. 

        How the storefront prepares a reboot
        -------------------------------------
        A reboot is initiated as a result of a tenant's actions in the storefront app's UI, specifically;
        - when a tenant clicks "install" or "uninstall" on an app, the storefront app calls POST /tenants/{}/patchSets,
        resulting in a reboot with [events like these](../examples/rebootStatus-juggleApps.json).
        - when a tenant clicks "reboot" on their tenant, the storefront app calls POST /tenants/{}/reboots,
        resulting in a reboot with [events like these](../examples/rebootStatus-simpleReboot.json).
        - when a tenant clicks "flush OAuth tokens" on their tenant, the storefront app calls POST /tenants/{}/OAuthFlushes,
        resulting in a reboot with [events like these](../examples/rebootStatus-bumpSecurityGeneration.json).

        How the storefront launches a reboot
        ------------------------------------
        When the storefront app calls the APIs above, the reboot does not start immediately. Instead, the APIs
        return a launch key.

        To actually start a reboot, the storefront app (typically from within a web page's
        onClick handler of a "Continue" button) uses this launch key to launch the reboot.

        As a reboot happens, TAS maintains the event history, and also a status for;
        - the tenant as a whole (see [tenant statuses](../schemas/tenantStatus.json))
        - each individual app

        Order of events during reboot
        -----------------------------
        During a reboot, the order of events is:

        - Halt all apps
          - TAS sets the tenant's status to "preHalting"
          - TAS calls /tenants/{}/preHalts on each installed app
          - When the last app returns 200, TAS sets the tenant's status to "preHalted"
          - TAS sets the tenant's status to "halting"
          - TAS calls /tenants/{}/halts on each installed app
          - When the last app returns 200, TAS sets the tenant's status to "halted"

        - TAS increments tenant.incarnation
        - TAS performs the actual operation, i.e.:
          - do nothing (if this reboot is in response to a call to POST /tenants/{}/reboots)
          - apply the patch set, e.g. to install an app (if this reboot is in response to a call to POST /tenants/{}/patchSets)
            - apps are installed or uninstalled
            - routes are adjusted
          - increment tenant.securityGeneration
            - explicitly (if this reboot is in response to a call to POST /tenants/{}/OAuthFlushes, i.e. the tenant clicked "Flush OAuth tokens"); or
            - implicitly (if this reboot is in response to a call to POST /tenants/{}/patchSets and
            TAS finds that the patch set is making changes to the tenant's idps or assertion hooks)
        - start all apps
          - TAS sets the tenant's status to "preStarting"
          - TAS calls /tenants/{}/inits on each installed app
          - When the last app returns 200, TAS sets the tenant's status to "preStarted"
          - TAS sets the tenant's status to "starting"
          - TAS calls /tenants/{}/starts on each installed app
          - When the last app returns 200, TAS sets the tenant's status to "starting"
                      
      /{launchKey}:
        post:
          description: |
            A storefront app's web page uses this API to launch a previously prepared reboot (if not already launched),
            and get the latest events and the current summary details.
            
            This endpoint is unauthenticated and has CORS headers that allow access from any domain (since the javascript calling it
            belongs to a storefront app which does not share the same domain as the tas core).
            
            If the apply is already "complete" then this call will return immediately, with any events that match the filter,
            up to the maximum events per call (100).
            
            Otherwise, the call blocks for .5 seconds to avoid thrashing, then returns as soon as at least one event is
            available that matches the filter, or the apply becomes complete (which would always be accompanied by an event).
            If no events are available after 60 seconds, the call returns indicating a timeout - the client will typically
            immediately make another call in a typical long-polling pattern, until the apply is marked as complete and the
            last event has been fetched.
            
          queryParameters:
            afterEvent:
              type: integer
              description: |
                The sequence of an existing event - this call should return events immediately *after* this event.
                Omitting this parameter returns the first events.
              example: 12
              required: false
          responses:
            200:
              body:
                application/json:
                  schema: !include ../schemas/rebootStatus.json
                  example: !include ../examples/rebootStatus-juggleApps.json
                            
/token:
  description: |
    About OAuth tokens
    ------------------
    API calls between apps (i.e. tenant API calls) are protected by OAuth. The consuming app must obtain an OAuth token from the TAS core,
    and pass it in the Authorization header when making the API call. For more background on OAuth and tokens, see the
    [OAuth 2 spec(http://tools.ietf.org/html/rfc6749') and also Google's
    [OAuth documentation](https://developers.google.com/accounts/docs/OAuth2WebServer) for additional context.

    In TAS, OAuth tokens are scoped by the consuming and producing app, i.e. a single token can be used by an app installed at a tenant
    (the consuming app) can use to consume any tenant API on a specific app installed at a tenant (the producing app).
    Currently, producing and consuming tenants are always the same.
    
    OAuth access tokens in TAS are self-contained security tokens in the form of a JWT (json web token; see http://jwt.io/).
    Because access tokens are self-contained and signed, producers can rely on their content without any network
    traffic to the authorization server (i.e. TAS core).

    On-behalf tokens
    ----------------
    Tokens may further be on-behalf, i.e. principal-aware, in which case they also identify some ultimate logged in end user
    who the API call is on behalf of. 


    Refresh tokens
    --------------
    Some apps need to continue making API calls on behalf of a user, even when the user is no longer logged in.
    
    Any app that is protected via TAS SSO and is marked as "offlineCapable" (TODO:
    exact name) can use the urn:ietf:params:oauth:client-assertion-type:saml2-bearer
    grant type (which requires a SAML assertion), and add the string "offline" to the scope
    parameter to create an on-behalf OAuth token and an accompanying refresh token.
    Your app should store the refresh token in its own long-term storage, and can use the access token immediately.
    
    The access token can be used immediately, and when it expires, the refresh token can be used to generate new
    access tokens even when the user is no longer logged in.
    
    Note: you only need to use refresh tokens if the offline activity is on behalf of a specific user. Otherwise
    your app can just use the client_credentials grant type to request a new OAuth token as soon as the existing one expires.

    Example:
        
    ````
    POST /oauth2/v1/token HTTP/1.1
    Host: core.talentappstore.com
    Content-Type: application/x-www-form-urlencoded

    grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-bearer
    scope=/acme/jobboard/acme/ats%20offline
    principal_type=candidate
    assertion=kjh9786gJHGutvfUT765Kkjghf70978klhjhgIUYGkpoiygEciYnjOi...
    Response:
    {
      "access_token":"iuhy76YT785L0GDF23JH7kjhd",
      "expires_in":3600,
      "token_type":"Bearer",
      "refresh_token":"j089777bhkltyHTRFG78969KJH968d"
    }
    ````
    
    Internally, TAS stores a copy of refresh tokens that it has issued, so it can validate
    requests for new access tokens. These refresh tokens are stored keyed by:
    - principal type
    - saml key (i.e. a key for the specific SAML assertion that was passed in the "assertion" parameter 
    user identifier (/E/N)
    - the SSO-protected app the user logged into (the API consuming app in this case)
    - consuming app install
    - producing app install
    
    Your app should save refresh tokens in long-term storage and continue to use them as long as they
    remain valid. If your app requests another refresh token for the same combination of
    values above, a new refresh token will be issued and any previous refresh token will be revoked.
    
    There is currently no support for refresh token revocation as per https://tools.ietf.org/html/rfc7009.

    Verifying incoming OAuth tokens
    -------------------------------
    To be secure, when an app receives an incoming tenant API call, it must:
    - Check that an incoming OAuth token was provided in the Authorization request header
    - Verify that the OAuth token was correctly signed by TAS core, and matches the public key from GET /OAuthKey.
    - Check that it is the correct audience (to prevent a malicious app using a token for your app which was intended for another app), i.e.;
      - the "pt" (producing tenant) field matches the current tenant (e.g. as extracted from the Host header)
      - the "pa" (producing app) field matches the shortCode hard-coded into the app's code
    - call GET /routes/{CT}/{CA}/{PT}/{PA} to verify that a route exists (to prevent a malicious app calling an API on your app which it has not declared that it calls)
    - check that whatever method is being used (GET, POST, etc.) is one of the supported methods declare on the API itself 

    Because performing the checks above involves making TAS core API calls, the producing app should attempt to cache the results whenever possible.

    For intra-tenant calls (i.e., where the producer and the consumer are the same), the
    producer can cache route verifications as long as the "sgen" (security generation) parameter
    in the token matches the app's own stored value for sgen.

    This works because sgen cannot be changed without bouncing the tenant, and every app is always
    informed when the tenant is bounced, so the producer always knows it has the latest value for
    sgen.

    A typical cache implementation might:
    - store verification outcomes for intra-tenant calls as booleans in a key value store
    - key the outcomes by some synthesised string like /routes/acme/uberapply/acme/ats/tas/%2Fcategories/GET
    - flush the cache whenever sgen changes

    For inter-tenant calls (i.e. where the consumer is a remote app likely installed at another tenant),
    the producer does not receive any notifications when the remote tenant is bounced. Therefore it
    has no way to maintain an up to date copy of the remote tenant's sgen value. This means that the producer
    must verify the route every time. This is not an issue until when/if TAS supports remote mounting.

  post:
    description: |
      Get a new access token, and optionally a refresh token.

      The request body must be of content-type application/x-www-form-urlencoded, and contain values for grant_type
      and optionally other parameters, encoded as per https://tools.ietf.org/html/rfc6749#appendix-B.
      See also https://tools.ietf.org/html/rfc7522#section-4.

      The core asserts that:
      - the consuming app is installed at the consuming tenant
      - the producing app is installed at the producing tenant
      - there exists at least one route between the consumer and producer, for any API (this prevents malicious apps probing for
      the presence of other apps)
        
      Every call to this endpoint results in a new access token being issued, with an expiry time set to one hour, or
      (as per http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithSAML.html) to the time specified in the SAML
      assertion's SessionNotOnOrAfter value (if present), whichever is shorter.
    
      If SessionNotOnOrAfter is in the past then token creation fails, and the app must somehow force the user to reauthenticate.
    
      For efficiency consumers should cache the tokens returned by this endpoint until (a) the tenant's security generation
      number changes, or (b) the cached token is too close to expiry to serve the needs of the consumer.

    body:
      application/x-www-form-urlencoded:
        formParameters:
          grant_type:
            description: |
               One of:
               - **client_credentials**: for an anonymous OAuth tokens that is not on behalf of any user/principal.
               Anonymous tokens are easy to create, but can't be used to consume on-behalf APIs, which tend to be those
               with principal-specific logic or security, e.g. only allowing users in the finance department to view
               account details, logging who the user was who created a job, etc. Anonymous access tokens always expire
               one hour after they are issued.
               - **urn:ietf:params:oauth:client-assertion-type:saml2-bearer**: for an on-behalf OAuth token that includes the identity
               of the user/principal who is the subject of the passed in SAML assertion. This grant type can only be used by apps that
               are protected via SSO. The token's expiry time will be either in one hour, or at the time dictated by the original SAML
                assertion's "on or before" field (TODO: be specific), whichever is sooner.
               - **urn:talentappstore.com:oauth:saml2-bearer-key**: As for urn:ietf:params:oauth:client-assertion-type:saml2-bearer, except
               that the key is used rather than the assertion itself.
               - **urn:talentappstore.com:oauth:tas-inherited**: for an on-behalf token that re-uses the user's identity from an incoming
               on-behalf token. Used by apps that both produce and consume on-behalf APIs; i.e. apps that are intermediate links in a chain
               of on-behalf API calls. The new access token inherits details of the principal (if any) and the expiry time 
               from the parent access token. This means all access tokens created as part of a nested set
               of API calls will expire simultaneously.
               - **refresh_token**: for an on-behalf token derived from a refresh token obtained previously via a call to the
               token endpoint with scope of "offline". The access token has a life of one hour. 
            type: string
            example: urn:talentappstore.com:oauth:saml2-bearer-key
          scope:
            description: |
              A space separated set of values for the OAuth scope of this token, which may include: 
              - A string starting with "/" that denotes a consuming app installed at a specific tenant
              and a producing app installed at a specific tenant (MUST be present for all grant types other than refresh_token)
              - the keyword "offline" (MAY be present only when grant_type is urn:ietf:params:oauth:client-assertion-type:saml2-bearer)
            type: string
            example: /acme/jobboard/acme/ats offline 
          principal_type:
            description: |
              The principal type the on-behalf token is being created for. MUST be present when grant_type is
              urn:ietf:params:oauth:client-assertion-type:saml2-bearer or
              urn:talentappstore.com:oauth:saml2-bearer-key. MUST NOT be present for other grant types.
            type: string
            example: candidate 
          refresh_token:
            description: |
              A refresh token obtained via a previous call to this endpoint with scope of offline. MUST be present when grant_type is
              refresh_token. MUST NOT be present for other grant types.
            type: string
          parent_token:
            description: |
              An access token passed in to the consuming app. MUST be present when grant_type is urn:talentappstore.com:oauth2:tas-inherited.
              MUST NOT be present for other grant types.
            type: string
          assertion:
            description: |
              The incoming SAML assertion. MUST be present for grant_type of urn:ietf:params:oauth:client-assertion-type:saml2-bearer.
              MUST NOT be present for other grant types. MUST contain an unexpired SAML assertion that matches exactly one as captured
              and stored by the TAS SAML proxy during login to *this app*.
          samlKey:
            description: |
              A reference to the incoming SAML assertion. MUST be present for grant_type of urn:talentappstore.com:oauth:saml2-bearer-ref.
              MUST NOT be present for other grant types. MUST contain a valid reference to an unexpired SAML assertion as captured
              and stored by the TAS SAML proxy during login *to this app*.
    responses:
      200:
        body:
          application/json:
            schema: !include ../schemas/tokenResponse.json
            example: !include ../examples/tokenResponse-simple.json

