<!DOCTYPE HTML><html><head><title>TAS core incoming (app -> TAS) API documentation</title><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="generator" content="https://github.com/kevinrenskers/raml2html 2.0.2"><link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/default.min.css"><script type="text/javascript" src="https://code.jquery.com/jquery-1.11.0.min.js"></script><script type="text/javascript" src="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/highlight.min.js"></script><script type="text/javascript">
      $(document).ready(function() {
        $('.page-header pre code, .top-resource-description pre code').each(function(i, block) {
          hljs.highlightBlock(block);
        });

        $('[data-toggle]').click(function() {
          var selector = $(this).data('target') + ' pre code';
          $(selector).each(function(i, block) {
            hljs.highlightBlock(block);
          });
        });

        // open modal on hashes like #_action_get
        $(window).bind('hashchange', function(e) {
          var anchor_id = document.location.hash.substr(1); //strip #
          var element = $('#' + anchor_id);

          // do we have such element + is it a modal?  --> show it
          if (element.length && element.hasClass('modal')) {
            element.modal('show');
          }
        });

        // execute hashchange on first page load
        $(window).trigger('hashchange');

        // remove url fragment on modal hide
        $('.modal').on('hidden.bs.modal', function() {
          if(history && history.replaceState) {
            history.replaceState({}, '', '#');
          }
        });
      });
    </script><style>
      .hljs {
        background: transparent;
      }
      .parent {
        color: #999;
      }
      .list-group-item > .badge {
        float: none;
        margin-right: 6px;
      }
      .panel-title > .methods {
        float: right;
      }
      .badge {
        border-radius: 0;
        text-transform: uppercase;
        width: 70px;
        font-weight: normal;
        color: #f3f3f6;
        line-height: normal;
      }
      .badge_get {
        background-color: #63a8e2;
      }
      .badge_post {
        background-color: #6cbd7d;
      }
      .badge_put {
        background-color: #22bac4;
      }
      .badge_delete {
        background-color: #d26460;
      }
      .badge_patch {
        background-color: #ccc444;
      }
      .list-group, .panel-group {
        margin-bottom: 0;
      }
      .panel-group .panel+.panel-white {
        margin-top: 0;
      }
      .panel-group .panel-white {
        border-bottom: 1px solid #F5F5F5;
        border-radius: 0;
      }
      .panel-white:last-child {
        border-bottom-color: white;
        -webkit-box-shadow: none;
        box-shadow: none;
      }
      .panel-white .panel-heading {
        background: white;
      }
      .tab-pane ul {
        padding-left: 2em;
      }
      .tab-pane h2 {
        font-size: 1.2em;
        padding-bottom: 4px;
        border-bottom: 1px solid #ddd;
      }
      .tab-pane h3 {
        font-size: 1.1em;
      }
      .tab-content {
        border-left: 1px solid #ddd;
        border-right: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        padding: 10px;
      }
      #sidebar {
        margin-top: 30px;
        padding-right: 5px;
        overflow: auto;
        height: 90%;
      }
      .top-resource-description {
        border-bottom: 1px solid #ddd;
        background: #fcfcfc;
        padding: 15px 15px 0 15px;
        margin: -15px -15px 10px -15px;
      }
      .resource-description {
        border-bottom: 1px solid #fcfcfc;
        background: #fcfcfc;
        padding: 15px 15px 0 15px;
        margin: -15px -15px 10px -15px;
      }
      .resource-description p:last-child {
        margin: 0;
      }
      .list-group .badge {
        float: left;
      }
      .method_description {
        margin-left: 85px;
      }
      .method_description p:last-child {
        margin: 0;
      }
      .list-group-item {
        cursor: pointer;
      }
      .list-group-item:hover {
        background-color: #f5f5f5;
      }
    </style></head><body data-spy="scroll" data-target="#sidebar"><div class="container"><div class="row"><div class="col-md-9" role="main"><div class="page-header"><h1>TAS core incoming (app -> TAS) API documentation <small>version v1</small></h1><p>http://talentappstore.com/v1</p><h3 id="Welcome"><a href="#Welcome">Welcome</a></h3><p>You&#39;re at the core API documentation for Talent App Store. If you&#39;ld like a higher level view, go to the <a href="http://developer.talentappstore.com">developer site</a>.</p><h3 id="HMAC"><a href="#HMAC">HMAC</a></h3><p>Most core API calls are secured using the same HMAC approach as <a href="http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">Amazon Web Service&#39;s Signature Version 4 signing process</a>, see also <a href="http://security.stackexchange.com/questions/77372/unusual-design-aspects-of-aws-hmac-based-authentication-v4">http://security.stackexchange.com/questions/77372/unusual-design-aspects-of-aws-hmac-based-authentication-v4</a>), except that whereas an AWS signature key is generated like this (see <a href="http://docs.aws.amazon.com/general/latest/gr/signature-v4-examples.html">http://docs.aws.amazon.com/general/latest/gr/signature-v4-examples.html</a>)...</p><pre><code>static byte[] getSignatureKey(String key, String dateStamp, String regionName, String serviceName) throws Exception  {
     byte[] kSecret = ("AWS4" + key).getBytes("UTF8");
     byte[] kDate    = HmacSHA256(dateStamp, kSecret);
     byte[] kRegion  = HmacSHA256(regionName, kDate);
     byte[] kService = HmacSHA256(serviceName, kRegion);
     byte[] kSigning = HmacSHA256("aws4_request", kService);
     return kSigning;
}
</code></pre><p>A TAS signature key for a core API call (in or out) is generated like this...</p><pre><code>static byte[] getSignatureKey(String key, String dateStamp) throws Exception  {
     byte[] kSecret = ("TAS4" + key).getBytes("UTF8");
     byte[] kDate    = HmacSHA256(dateStamp, kSecret);
     byte[] kSigning = HmacSHA256("tas4_request", kService);
     return kSigning;
}
</code></pre></div><div class="panel panel-default"><div class="panel-heading"><h3 id="apps" class="panel-title">/apps</h3></div><div class="panel-body"><div class="top-resource-description"><p>An <em>app</em> is a microservice that can be installed by a tenant</p></div><div class="panel-group"><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_apps__app_"><span class="parent">/apps</span>/{app}</a> <span class="methods"><a href="#apps__app__get"><span class="badge badge_get">get</span></a></span></h4></div><div id="panel_apps__app_" class="panel-collapse collapse"><div class="panel-body"><div class="list-group"><div onclick="window.location.href = '#apps__app__get'" class="list-group-item"><span class="badge badge_get">get</span><div class="method_description"><p>Get details of the app. This is useful when some piece of software (like a proxy) is acting on behalf of the app, but has only been given its shortCode and secret key.</p><p>The core asserts that:</p><ul><li>the call is being made by the app itself</li></ul></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="apps__app__get"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_get">get</span> <span class="parent">/apps</span>/{app}</h4></div><div class="modal-body"><div class="alert alert-info"><p>Get details of the app. This is useful when some piece of software (like a proxy) is acting on behalf of the app, but has only been given its shortCode and secret key.</p><p>The core asserts that:</p><ul><li>the call is being made by the app itself</li></ul></div><ul class="nav nav-tabs"><li class="active"><a href="#apps__app__get_request" data-toggle="tab">Request</a></li><li><a href="#apps__app__get_response" data-toggle="tab">Response</a></li></ul><div class="tab-content"><div class="tab-pane active" id="apps__app__get_request"><h3>URI Parameters</h3><ul><li><strong>app</strong>: <em>required (string)</em></li></ul></div><div class="tab-pane" id="apps__app__get_response"><h2>HTTP status code <a href="http://httpstatus.es/200" target="_blank">200</a></h2><h3>Body</h3><p><strong>Type: application/json</strong></p><p><strong>Schema</strong>:</p><pre><code>{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "type": "object",
    "additionalProperties": false,
    "properties": {
        "shortCode": {
            "type": "string",
            "description": "a short, lower case identifier for the app, e.g. jobboard"
        },
        "developer": {
            "type": "string",
            "description": "the shortCode for the app&#39;s developer"
        }
    },
    "required": ["shortCode","developer"]
}</code></pre><p><strong>Example</strong>:</p><pre><code>{
        "shortCode": "jobboard",
        "developer": "supersoft"
}</code></pre></div></div></div></div></div></div></div></div></div></div><div class="panel panel-default"><div class="panel-heading"><h3 id="OAuthKey" class="panel-title">/OAuthKey</h3></div><div class="panel-body"><div class="top-resource-description"><p>The <em>OAuth public key</em> is used by apps to verify that incoming OAuth tokens were indeed issued by TAS.</p></div><div class="panel-group"><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_OAuthKey"><span class="parent"></span>/OAuthKey</a> <span class="methods"><a href="#OAuthKey_get"><span class="badge badge_get">get</span></a></span></h4></div><div id="panel_OAuthKey" class="panel-collapse collapse"><div class="panel-body"><div class="list-group"><div onclick="window.location.href = '#OAuthKey_get'" class="list-group-item"><span class="badge badge_get">get</span><div class="method_description"><p>Get the current public key used by TASA to sign OAuth tokens.</p></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="OAuthKey_get"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_get">get</span> <span class="parent"></span>/OAuthKey</h4></div><div class="modal-body"><div class="alert alert-info"><p>Get the current public key used by TASA to sign OAuth tokens.</p></div><ul class="nav nav-tabs"><li><a href="#OAuthKey_get_response" data-toggle="tab">Response</a></li></ul><div class="tab-content"><div class="tab-pane" id="OAuthKey_get_response"><h2>HTTP status code <a href="http://httpstatus.es/200" target="_blank">200</a></h2><h3>Body</h3><p><strong>Type: text/plain</strong></p><p><strong>Example</strong>:</p><pre><code>kuh9876guhgfyr76453dytrfUTYGuytfUrt</code></pre></div></div></div></div></div></div></div></div></div></div><div class="panel panel-default"><div class="panel-heading"><h3 id="patchSets" class="panel-title">/patchSets</h3></div><div class="panel-body"><div class="panel-group"><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_patchSets"><span class="parent"></span>/patchSets</a> <span class="methods"><a href="#patchSets_post"><span class="badge badge_post">post</span></a></span></h4></div><div id="panel_patchSets" class="panel-collapse collapse"><div class="panel-body"><div class="list-group"><div onclick="window.location.href = '#patchSets_post'" class="list-group-item"><span class="badge badge_post">post</span><div class="method_description"><p>This endpoint behaves exactly as per /tenants/{tenant}/patchSets, except that it creates a tenant rather than applying patches to an existing tenant.</p><p>The core asserts that:</p><ul><li>the app is marked as "storeFront"</li></ul></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="patchSets_post"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_post">post</span> <span class="parent"></span>/patchSets</h4></div><div class="modal-body"><div class="alert alert-info"><p>This endpoint behaves exactly as per /tenants/{tenant}/patchSets, except that it creates a tenant rather than applying patches to an existing tenant.</p><p>The core asserts that:</p><ul><li>the app is marked as "storeFront"</li></ul></div><ul class="nav nav-tabs"></ul><div class="tab-content"></div></div></div></div></div></div><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_patchSets__launchKey_"><span class="parent">/patchSets</span>/{launchKey}</a> <span class="methods"><a href="#patchSets__launchKey__post"><span class="badge badge_post">post</span></a></span></h4></div><div id="panel_patchSets__launchKey_" class="panel-collapse collapse"><div class="panel-body"><div class="list-group"><div onclick="window.location.href = '#patchSets__launchKey__post'" class="list-group-item"><span class="badge badge_post">post</span><div class="method_description"><p>This endpoint behaves exactly as per /tenants/{tenant}/patchSets/{launchKey}, except that it works against a tenant-creating patchSet, rather than a patchSet that is modifying an existing tenant.</p><p>The core asserts that:</p><ul><li>the app is marked as "storeFront"</li></ul></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="patchSets__launchKey__post"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_post">post</span> <span class="parent">/patchSets</span>/{launchKey}</h4></div><div class="modal-body"><div class="alert alert-info"><p>This endpoint behaves exactly as per /tenants/{tenant}/patchSets/{launchKey}, except that it works against a tenant-creating patchSet, rather than a patchSet that is modifying an existing tenant.</p><p>The core asserts that:</p><ul><li>the app is marked as "storeFront"</li></ul></div><ul class="nav nav-tabs"><li class="active"><a href="#patchSets__launchKey__post_request" data-toggle="tab">Request</a></li></ul><div class="tab-content"><div class="tab-pane active" id="patchSets__launchKey__post_request"><h3>URI Parameters</h3><ul><li><strong>launchKey</strong>: <em>required (string)</em></li></ul></div></div></div></div></div></div></div></div></div></div><div class="panel panel-default"><div class="panel-heading"><h3 id="ping" class="panel-title">/ping</h3></div><div class="panel-body"><div class="top-resource-description"><p>A ping is the simplest call an app can make against the TAS core</p></div><div class="panel-group"><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_ping"><span class="parent"></span>/ping</a> <span class="methods"><a href="#ping_get"><span class="badge badge_get">get</span></a></span></h4></div><div id="panel_ping" class="panel-collapse collapse"><div class="panel-body"><div class="list-group"><div onclick="window.location.href = '#ping_get'" class="list-group-item"><span class="badge badge_get">get</span><div class="method_description"><p>Always return http 200. Useful for testing app is working OK (has correct secret key etc.).</p></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="ping_get"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_get">get</span> <span class="parent"></span>/ping</h4></div><div class="modal-body"><div class="alert alert-info"><p>Always return http 200. Useful for testing app is working OK (has correct secret key etc.).</p></div><ul class="nav nav-tabs"><li><a href="#ping_get_response" data-toggle="tab">Response</a></li></ul><div class="tab-content"><div class="tab-pane" id="ping_get_response"><h2>HTTP status code <a href="http://httpstatus.es/200" target="_blank">200</a></h2></div></div></div></div></div></div></div></div></div></div><div class="panel panel-default"><div class="panel-heading"><h3 id="routes" class="panel-title">/routes</h3></div><div class="panel-body"><div class="top-resource-description"><h2 id="about-routes">About routes</h2><p>Routes reflect a possible point to point API call between two apps on behalf of a tenant. They are usages:</p><ul><li>of a tenant API</li><li>as produced in a specific way (source of truth or not)</li><li>by a consuming app</li><li>installed at a tenant</li><li>on a producing app (currently, always the same as the consuming tenant)</li><li>installed at a tenant</li></ul><p>To consume a tenant API, the consuming app must first fetch a route in order to locate the actual endpoint (where the producer&#39;s server sits on the internet).</p><p>Routes are also useful to the producer of an API, e.g. to validate the methods (POST, GET, etc.) that the consumer is allowed to call.</p><h2 id="remote-mounting">Remote mounting</h2><p>Remote mounting is a possible future feature of TAS. It is not currently implemented.</p><p>With remote mounting, apps can produce APIs (SoT or non-SoT) by remote mounting a specified tenant&#39;s SoT production of the same API.</p><p>For example:</p><ul><li>tenant acme has installed a number of job board apps</li><li>the tenant wants each job board app to produce (non-SoT) the /categories API</li><li>so that acme&#39;s other apps can query each job board&#39;s unique category setup, build mappings, etc.</li><li>the job board "green jobs" provides such a job board app</li><li>that app produces (non-SoT) /categories</li><li>however it does so by remote mounting the same API at the central green jobs tenant</li><li>inside the green jobs tenant, the app "corestuff" produces (SoT) the /categories API</li><li>therefore corestuff finishes up producing the API when consumed by some other app at the acme tenant</li></ul><p>TAS detects and disallows loops.</p></div><div class="panel-group"><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_routes__CT_"><span class="parent">/routes</span>/{CT}</a> <span class="methods"></span></h4></div><div id="panel_routes__CT_" class="panel-collapse collapse"><div class="panel-body"><div class="resource-description"><p>Consuming tenant: the tenant with the app installed that is consuming the API</p></div><div class="list-group"></div></div></div></div><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_routes__CT___CA_"><span class="parent">/routes/{CT}</span>/{CA}</a> <span class="methods"><a href="#routes__CT___CA__get"><span class="badge badge_get">get</span></a></span></h4></div><div id="panel_routes__CT___CA_" class="panel-collapse collapse"><div class="panel-body"><div class="resource-description"><p>Consuming app: the app consuming the API</p></div><div class="list-group"><div onclick="window.location.href = '#routes__CT___CA__get'" class="list-group-item"><span class="badge badge_get">get</span><div class="method_description"><p>Used by tenant API consumers to fetch the route(s) from the consumer to each producer of a specific API.</p><p>The core checks that:</p><ul><li>the app making the core API call is the consuming app (i.e., matches {CA})</li><li>the consuming app is installed at {CT}</li><li>the consuming app has declared that it consumes the given API, in the given way (SoT or not).</li></ul></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="routes__CT___CA__get"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_get">get</span> <span class="parent">/routes/{CT}</span>/{CA}</h4></div><div class="modal-body"><div class="alert alert-info"><p>Used by tenant API consumers to fetch the route(s) from the consumer to each producer of a specific API.</p><p>The core checks that:</p><ul><li>the app making the core API call is the consuming app (i.e., matches {CA})</li><li>the consuming app is installed at {CT}</li><li>the consuming app has declared that it consumes the given API, in the given way (SoT or not).</li></ul></div><ul class="nav nav-tabs"><li class="active"><a href="#routes__CT___CA__get_request" data-toggle="tab">Request</a></li><li><a href="#routes__CT___CA__get_response" data-toggle="tab">Response</a></li></ul><div class="tab-content"><div class="tab-pane active" id="routes__CT___CA__get_request"><h3>URI Parameters</h3><ul><li><strong>CT</strong>: <em>required (string)</em></li><li><strong>CA</strong>: <em>required (string)</em></li></ul><h3>Query Parameters</h3><ul><li><strong>apiDev</strong>: <em>required (string)</em><p>Developer who defined the API</p><p><strong>Example</strong>:</p><pre>tas</pre></li><li><strong>api</strong>: <em>required (string)</em><p>API URI Template: the URI template (as per <a href="https://tools.ietf.org/html/rfc6570">https://tools.ietf.org/html/rfc6570</a>) of the API being consumed. The URI must be encoded as per <a href="http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4">http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4</a>, for example in Java using the URLEncoder class <a href="http://docs.oracle.com/javase/8/docs/api/java/net/URLEncoder.html">http://docs.oracle.com/javase/8/docs/api/java/net/URLEncoder.html</a>.</p><p>For example, if the API is /jobs/{job}, then you would pass %2fjobs%2f%7bjob%7d.</p><p><strong>Example</strong>:</p><pre>%2fjobs%2f%7bjob%7d
</pre></li><li><strong>sot</strong>: <em>required (boolean)</em><p>True if the consuming app is consuming this as SoT (source of truth), otherwise false</p><p><strong>Example</strong>:</p><pre><code>true</code></pre></li></ul></div><div class="tab-pane" id="routes__CT___CA__get_response"><h2>HTTP status code <a href="http://httpstatus.es/200" target="_blank">200</a></h2><h3>Body</h3><p><strong>Type: application/json</strong></p><p><strong>Schema</strong>:</p><pre><code>{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "type": "object",
    "properties": {
        "consumingAppInstall": {
            "$ref": "./routeBase.json#/definitions/installDetail"
        },
        "consumedApi": {
            "$ref": "./routeBase.json#/definitions/consumedApi"
        },
        "producingAppInstalls": {
            "type": "array",
            "items": {
                "$ref": "./routeBase.json#/definitions/installDetail"
            }
        }
    }
}</code></pre><p><strong>Example</strong>:</p><pre><code>{
    "consumingAppInstall": {
        "tenant": "acme",
        "app": "jobboardhub",
        "methods": [
            "GET",
            "POST"
        ],
        "securityGeneration": 1409
    },
    "consumedApi": {
        "apiDeveloper": "tas",
        "apiUriTemplate": "/categories",
        "consumedAsSourceOfTruth": false,
        "methods": [
            "GET",
            "POST",
            "DELETE"
        ]
    },
    "producingAppInstalls": [
        {
            "tenant": "seek",
            "app": "basecats",
            "endPoint": "https://ref.seek.com:2109/api/v3.2",
            "securityGeneration": 301
        },
        {
            "tenant": "greenjobsite",
            "app": "gjcore",
            "endPoint": "https://api.greenjobs.co.nz/v1",
            "securityGeneration": 80
        }
    ]
}
</code></pre></div></div></div></div></div></div></div><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_routes__CT___CA___PT_"><span class="parent">/routes/{CT}/{CA}</span>/{PT}</a> <span class="methods"></span></h4></div><div id="panel_routes__CT___CA___PT_" class="panel-collapse collapse"><div class="panel-body"><div class="resource-description"><p>Producing tenant: the tenant with the app installed that is producing the API</p></div><div class="list-group"></div></div></div></div><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_routes__CT___CA___PT___PA_"><span class="parent">/routes/{CT}/{CA}/{PT}</span>/{PA}</a> <span class="methods"><a href="#routes__CT___CA___PT___PA__get"><span class="badge badge_get">get</span></a></span></h4></div><div id="panel_routes__CT___CA___PT___PA_" class="panel-collapse collapse"><div class="panel-body"><div class="resource-description"><p>Producing app: the app producing the API</p></div><div class="list-group"><div onclick="window.location.href = '#routes__CT___CA___PT___PA__get'" class="list-group-item"><span class="badge badge_get">get</span><div class="method_description"><p>Used by tenant API producers to verify that the consumer is allowed to consume this API.</p><p>The core will assert that:</p><ul><li>the app making the core API call is the producing app (i.e., matches {PA})</li><li>the producing app is installed at {PT}</li><li>the consuming app has declared that it consumes the given API</li><li>the producing app has declared that it produces the given API</li><li>the consuming app has declared that it consumes the given API in the same way that the producer has declared that it produces it (SoT or not).</li></ul><p>Since both consuming and producing apps are specified, there can only be one or zero routes in the response.</p></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="routes__CT___CA___PT___PA__get"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_get">get</span> <span class="parent">/routes/{CT}/{CA}/{PT}</span>/{PA}</h4></div><div class="modal-body"><div class="alert alert-info"><p>Used by tenant API producers to verify that the consumer is allowed to consume this API.</p><p>The core will assert that:</p><ul><li>the app making the core API call is the producing app (i.e., matches {PA})</li><li>the producing app is installed at {PT}</li><li>the consuming app has declared that it consumes the given API</li><li>the producing app has declared that it produces the given API</li><li>the consuming app has declared that it consumes the given API in the same way that the producer has declared that it produces it (SoT or not).</li></ul><p>Since both consuming and producing apps are specified, there can only be one or zero routes in the response.</p></div><ul class="nav nav-tabs"><li class="active"><a href="#routes__CT___CA___PT___PA__get_request" data-toggle="tab">Request</a></li><li><a href="#routes__CT___CA___PT___PA__get_response" data-toggle="tab">Response</a></li></ul><div class="tab-content"><div class="tab-pane active" id="routes__CT___CA___PT___PA__get_request"><h3>URI Parameters</h3><ul><li><strong>CT</strong>: <em>required (string)</em></li><li><strong>CA</strong>: <em>required (string)</em></li><li><strong>PT</strong>: <em>required (string)</em></li><li><strong>PA</strong>: <em>required (string)</em></li></ul><h3>Query Parameters</h3><ul><li><strong>apiDev</strong>: <em>required (string)</em><p>Developer who defined the API</p><p><strong>Example</strong>:</p><pre>tas</pre></li><li><strong>api</strong>: <em>required (string)</em><p>API URI Template: the URI template (as per <a href="https://tools.ietf.org/html/rfc6570">https://tools.ietf.org/html/rfc6570</a>) of the API being consumed. The URI must be encoded as per <a href="http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4">http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4</a>, for example in Java using the URLEncoder class <a href="http://docs.oracle.com/javase/8/docs/api/java/net/URLEncoder.html">http://docs.oracle.com/javase/8/docs/api/java/net/URLEncoder.html</a>.</p><p>For example, if the API is /jobs/{job}, then you would pass %2fjobs%2f%7bjob%7d.</p><p><strong>Example</strong>:</p><pre>%2fjobs%2f%7bjob%7d
</pre></li></ul></div><div class="tab-pane" id="routes__CT___CA___PT___PA__get_response"><h2>HTTP status code <a href="http://httpstatus.es/200" target="_blank">200</a></h2><h3>Body</h3><p><strong>Type: application/json</strong></p><p><strong>Schema</strong>:</p><pre><code>{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "type": "object",
    "properties": {
        "consumingAppInstall": {
            "$ref": "./routeBase.json#/definitions/installDetail"
        },
        "consumedApi": {
            "$ref": "./routeBase.json#/definitions/consumedApi"
        },
        "producingAppInstall": {
            "$ref": "./routeBase.json#/definitions/installDetail"
        }
    }
}</code></pre><p><strong>Example</strong>:</p><pre><code>{
    "consumingAppInstall": {
        "tenant": "acme",
        "app": "jobboardhub",
        "methods": [
            "GET",
            "POST"
        ],
        "securityGeneration": 1409
    },
    "consumedApi": {
        "apiDeveloper": "tas",
        "apiUriTemplate": "/categories",
        "consumedAsSourceOfTruth": false,
        "methods": [
            "GET",
            "POST",
            "DELETE"
        ]
    },
    "producingAppInstall": {
        "tenant": "seek",
        "app": "basecats",
        "endPoint": "https://ref.seek.com:2109/api/v3.2",
        "securityGeneration": 301
    }
}</code></pre></div></div></div></div></div></div></div></div></div></div><div class="panel panel-default"><div class="panel-heading"><h3 id="saml" class="panel-title">/saml</h3></div><div class="panel-body"><div class="panel-group"><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_saml_assertions__PT_"><span class="parent">/saml/assertions</span>/{PT}</a> <span class="methods"></span></h4></div><div id="panel_saml_assertions__PT_" class="panel-collapse collapse"><div class="panel-body"><div class="resource-description"><p>The principal type of the SAML assertion.</p></div><div class="list-group"></div></div></div></div><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_saml_assertions__PT___key_"><span class="parent">/saml/assertions/{PT}</span>/{key}</a> <span class="methods"><a href="#saml_assertions__PT___key__get"><span class="badge badge_get">get</span></a></span></h4></div><div id="panel_saml_assertions__PT___key_" class="panel-collapse collapse"><div class="panel-body"><div class="list-group"><div onclick="window.location.href = '#saml_assertions__PT___key__get'" class="list-group-item"><span class="badge badge_get">get</span><div class="method_description"><p>Fetch a SAML assertion via its database key.</p><p>The core asserts that:</p><ul><li>either the app is linked to the given principal type; or</li><li>the app produces (as SoT or not) at least one on-behalf API which is linked to the given principal type</li><li>if found, the assertion has not expired (based on the stored assertion detail)</li></ul></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="saml_assertions__PT___key__get"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_get">get</span> <span class="parent">/saml/assertions/{PT}</span>/{key}</h4></div><div class="modal-body"><div class="alert alert-info"><p>Fetch a SAML assertion via its database key.</p><p>The core asserts that:</p><ul><li>either the app is linked to the given principal type; or</li><li>the app produces (as SoT or not) at least one on-behalf API which is linked to the given principal type</li><li>if found, the assertion has not expired (based on the stored assertion detail)</li></ul></div><ul class="nav nav-tabs"><li class="active"><a href="#saml_assertions__PT___key__get_request" data-toggle="tab">Request</a></li><li><a href="#saml_assertions__PT___key__get_response" data-toggle="tab">Response</a></li></ul><div class="tab-content"><div class="tab-pane active" id="saml_assertions__PT___key__get_request"><h3>URI Parameters</h3><ul><li><strong>PT</strong>: <em>required (string)</em></li><li><strong>key</strong>: <em>required (string)</em></li></ul></div><div class="tab-pane" id="saml_assertions__PT___key__get_response"><h2>HTTP status code <a href="http://httpstatus.es/200" target="_blank">200</a></h2><h3>Body</h3><p><strong>Type: application/xml</strong></p></div></div></div></div></div></div></div><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_saml_keyLookups__PT_"><span class="parent">/saml/keyLookups</span>/{PT}</a> <span class="methods"><a href="#saml_keyLookups__PT__post"><span class="badge badge_post">post</span></a></span></h4></div><div id="panel_saml_keyLookups__PT_" class="panel-collapse collapse"><div class="panel-body"><div class="resource-description"><p>the principal type the assertion is for</p></div><div class="list-group"><div onclick="window.location.href = '#saml_keyLookups__PT__post'" class="list-group-item"><span class="badge badge_post">post</span><div class="method_description"><p>Fetch the key of an incoming SAML assertion. Used by apps which include their own SAML SP layer (rather than sitting behind the proxy). TAS acts as a SAML proxy, and captures and stores assertions in an internal database, partitioned by principal type, prior to handing them off to the app (SP).</p><p>The request body contains the content of the assertion to search for.</p><p>The core asserts that:</p><ul><li>the app making the call is linked to the given principal type</li><li>the assertion has not expired (based on the passed in assertion detail)</li></ul></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="saml_keyLookups__PT__post"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_post">post</span> <span class="parent">/saml/keyLookups</span>/{PT}</h4></div><div class="modal-body"><div class="alert alert-info"><p>Fetch the key of an incoming SAML assertion. Used by apps which include their own SAML SP layer (rather than sitting behind the proxy). TAS acts as a SAML proxy, and captures and stores assertions in an internal database, partitioned by principal type, prior to handing them off to the app (SP).</p><p>The request body contains the content of the assertion to search for.</p><p>The core asserts that:</p><ul><li>the app making the call is linked to the given principal type</li><li>the assertion has not expired (based on the passed in assertion detail)</li></ul></div><ul class="nav nav-tabs"><li class="active"><a href="#saml_keyLookups__PT__post_request" data-toggle="tab">Request</a></li></ul><div class="tab-content"><div class="tab-pane active" id="saml_keyLookups__PT__post_request"><h3>URI Parameters</h3><ul><li><strong>PT</strong>: <em>required (string)</em></li></ul><h3>Body</h3><p><strong>Type: application/xml</strong></p></div></div></div></div></div></div></div></div></div></div><div class="panel panel-default"><div class="panel-heading"><h3 id="tenants" class="panel-title">/tenants</h3></div><div class="panel-body"><div class="top-resource-description"><p>A <em>tenant</em> is a customer within the multi-tenanted environment of Talent App Store.</p></div><div class="panel-group"><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_tenants__tenant_"><span class="parent">/tenants</span>/{tenant}</a> <span class="methods"><a href="#tenants__tenant__get"><span class="badge badge_get">get</span></a></span></h4></div><div id="panel_tenants__tenant_" class="panel-collapse collapse"><div class="panel-body"><div class="list-group"><div onclick="window.location.href = '#tenants__tenant__get'" class="list-group-item"><span class="badge badge_get">get</span><div class="method_description"><p>Get details of the tenant.</p><p>The core asserts that:</p><ul><li>the app is installed by the tenant</li></ul></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="tenants__tenant__get"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_get">get</span> <span class="parent">/tenants</span>/{tenant}</h4></div><div class="modal-body"><div class="alert alert-info"><p>Get details of the tenant.</p><p>The core asserts that:</p><ul><li>the app is installed by the tenant</li></ul></div><ul class="nav nav-tabs"><li class="active"><a href="#tenants__tenant__get_request" data-toggle="tab">Request</a></li><li><a href="#tenants__tenant__get_response" data-toggle="tab">Response</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tenants__tenant__get_request"><h3>URI Parameters</h3><ul><li><strong>tenant</strong>: <em>required (string)</em></li></ul></div><div class="tab-pane" id="tenants__tenant__get_response"><h2>HTTP status code <a href="http://httpstatus.es/200" target="_blank">200</a></h2><h3>Body</h3><p><strong>Type: application/json</strong></p><p><strong>Schema</strong>:</p><pre><code>{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "type": "object",
    "additionalProperties": false,
    "properties": {
        "name": {
            "type": "string",
            "description": "name of the tenant"
        },
        "shortCode": {
            "type": "string",
            "description": "a short, lower case identifier for the tenant, e.g. acme"
        },
        "description": {
            "type": "string",
            "description": "description for this tenant"
        },
        "type": {
            "enum": [
                "PRODUCTION",
                "SANDBOX"
            ],
            "description": "The type of tenant, i.e. sandbox or not. Apps behave differently when installed in a sandbox."
        },
        "logoUrl": {
            "type": "string",
            "description": "url for the tenant&#39;s logo"
        }
    },
    "required": ["name","shortCode","description","type"]
}</code></pre><p><strong>Example</strong>:</p><pre><code>{
 "shortCode": "acme-sandbox-1",
 "name": "Acme sandbox testing site",
 "description": "not for sharing",
 "type": "SANDBOX",
 "logoUrl": "https://s3-aws.com/786745987969"  
}
</code></pre></div></div></div></div></div></div></div><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_tenants__tenant__status"><span class="parent">/tenants/{tenant}</span>/status</a> <span class="methods"><a href="#tenants__tenant__status_get"><span class="badge badge_get">get</span></a></span></h4></div><div id="panel_tenants__tenant__status" class="panel-collapse collapse"><div class="panel-body"><div class="list-group"><div onclick="window.location.href = '#tenants__tenant__status_get'" class="list-group-item"><span class="badge badge_get">get</span><div class="method_description"><p>Get the status of the tenant, including the current state and security generation. Normally apps would use this information when restarting to determine whether to flush cached OAuth tokens and routes.</p><p>The core asserts that:</p><ul><li>the app is installed by the tenant</li></ul></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="tenants__tenant__status_get"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_get">get</span> <span class="parent">/tenants/{tenant}</span>/status</h4></div><div class="modal-body"><div class="alert alert-info"><p>Get the status of the tenant, including the current state and security generation. Normally apps would use this information when restarting to determine whether to flush cached OAuth tokens and routes.</p><p>The core asserts that:</p><ul><li>the app is installed by the tenant</li></ul></div><ul class="nav nav-tabs"><li class="active"><a href="#tenants__tenant__status_get_request" data-toggle="tab">Request</a></li><li><a href="#tenants__tenant__status_get_response" data-toggle="tab">Response</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tenants__tenant__status_get_request"><h3>URI Parameters</h3><ul><li><strong>tenant</strong>: <em>required (string)</em></li></ul></div><div class="tab-pane" id="tenants__tenant__status_get_response"><h2>HTTP status code <a href="http://httpstatus.es/200" target="_blank">200</a></h2><h3>Body</h3><p><strong>Type: application/json</strong></p><p><strong>Schema</strong>:</p><pre><code>{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "type": "object",
    "additionalProperties": false,
    "properties": {
        "incarnation": {
            "type": "integer",
            "description": "a number representing the &#39;configuration version&#39; of this tenant. Incremented on any changes to the installed apps."
        },
        "securityGeneration": {
            "type": "integer",
            "description": "a number representing the &#39;security version&#39; of this tenant. Incremented when tenant signals such during a patch operation."
        },
        "state": {
            "enum": [
                "PREHALTING",
                "PREHALTED",
                "HALTING",
                "HALTED",
                "PRESTARTING",
                "PRESTARTED",
                "STARTING",
                "STARTED",
                "BROKEN"
            ],
            "description": "The tenant&#39;s current status."
        }
    },
    "required": [ "incarnation", "securityGeneration"]
}</code></pre><p><strong>Example</strong>:</p><pre><code>{
 "incarnation": 1046,
 "securityGeneration": 12,
 "state": "HALTING"
}

</code></pre></div></div></div></div></div></div></div><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_tenants__tenant__samlSPMetadata"><span class="parent">/tenants/{tenant}</span>/samlSPMetadata</a> <span class="methods"><a href="#tenants__tenant__samlSPMetadata_get"><span class="badge badge_get">get</span></a></span></h4></div><div id="panel_tenants__tenant__samlSPMetadata" class="panel-collapse collapse"><div class="panel-body"><div class="resource-description"><p>Apps that are SSO-protected (i.e., SPs in SAML lingo) require their own SAML metadata</p></div><div class="list-group"><div onclick="window.location.href = '#tenants__tenant__samlSPMetadata_get'" class="list-group-item"><span class="badge badge_get">get</span><div class="method_description"><p>Get the metadata for this app (the SP).</p><p>The core asserts that:</p><ul><li>the app is linked to any principal type (i.e., it uses SSO)</li></ul></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="tenants__tenant__samlSPMetadata_get"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_get">get</span> <span class="parent">/tenants/{tenant}</span>/samlSPMetadata</h4></div><div class="modal-body"><div class="alert alert-info"><p>Get the metadata for this app (the SP).</p><p>The core asserts that:</p><ul><li>the app is linked to any principal type (i.e., it uses SSO)</li></ul></div><ul class="nav nav-tabs"><li class="active"><a href="#tenants__tenant__samlSPMetadata_get_request" data-toggle="tab">Request</a></li><li><a href="#tenants__tenant__samlSPMetadata_get_response" data-toggle="tab">Response</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tenants__tenant__samlSPMetadata_get_request"><h3>URI Parameters</h3><ul><li><strong>tenant</strong>: <em>required (string)</em></li></ul></div><div class="tab-pane" id="tenants__tenant__samlSPMetadata_get_response"><h2>HTTP status code <a href="http://httpstatus.es/200" target="_blank">200</a></h2><h3>Body</h3><p><strong>Type: application/xml</strong></p></div></div></div></div></div></div></div><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_tenants__tenant__samlIdPMetadata"><span class="parent">/tenants/{tenant}</span>/samlIdPMetadata</a> <span class="methods"><a href="#tenants__tenant__samlIdPMetadata_get"><span class="badge badge_get">get</span></a></span></h4></div><div id="panel_tenants__tenant__samlIdPMetadata" class="panel-collapse collapse"><div class="panel-body"><div class="resource-description"><p>Apps that are SSO-protected (i.e., SPs in SAML lingo) require the SAML metadata for the IdP proxy that front ends all of the identity providers that the tenant has set up.</p></div><div class="list-group"><div onclick="window.location.href = '#tenants__tenant__samlIdPMetadata_get'" class="list-group-item"><span class="badge badge_get">get</span><div class="method_description"><p>description: Get the metadata for the IdP proxy.</p><p>The core asserts that:</p><ul><li>the app is linked to any principal type (i.e., it uses SSO)</li></ul></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="tenants__tenant__samlIdPMetadata_get"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_get">get</span> <span class="parent">/tenants/{tenant}</span>/samlIdPMetadata</h4></div><div class="modal-body"><div class="alert alert-info"><p>description: Get the metadata for the IdP proxy.</p><p>The core asserts that:</p><ul><li>the app is linked to any principal type (i.e., it uses SSO)</li></ul></div><ul class="nav nav-tabs"><li class="active"><a href="#tenants__tenant__samlIdPMetadata_get_request" data-toggle="tab">Request</a></li><li><a href="#tenants__tenant__samlIdPMetadata_get_response" data-toggle="tab">Response</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tenants__tenant__samlIdPMetadata_get_request"><h3>URI Parameters</h3><ul><li><strong>tenant</strong>: <em>required (string)</em></li></ul></div><div class="tab-pane" id="tenants__tenant__samlIdPMetadata_get_response"><h2>HTTP status code <a href="http://httpstatus.es/200" target="_blank">200</a></h2><h3>Body</h3><p><strong>Type: application/xml</strong></p></div></div></div></div></div></div></div><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_tenants__tenant__OAuthFlushes"><span class="parent">/tenants/{tenant}</span>/OAuthFlushes</a> <span class="methods"><a href="#tenants__tenant__OAuthFlushes_post"><span class="badge badge_post">post</span></a></span></h4></div><div id="panel_tenants__tenant__OAuthFlushes" class="panel-collapse collapse"><div class="panel-body"><div class="list-group"><div onclick="window.location.href = '#tenants__tenant__OAuthFlushes_post'" class="list-group-item"><span class="badge badge_post">post</span><div class="method_description"><p>A storefront app calls this endpoint to reboot the tenant and increment the security generation. This effectively (since apps should always check for changed security generation) invalidates all OAuth tokens for APIs consumed or produced by this tenant. This is used to mitigate an attack where an app has an OAuth token stolen from it (tenant admin person clicks "Flush credentials" in the storefront).</p><p>The response body is an unguessable unique "launch key" which is then used with POST /tenants/{tenant}/reboots/{launchKey}.</p><p>The core asserts that:</p><ul><li>the app is marked as "storeFront".</li></ul></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="tenants__tenant__OAuthFlushes_post"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_post">post</span> <span class="parent">/tenants/{tenant}</span>/OAuthFlushes</h4></div><div class="modal-body"><div class="alert alert-info"><p>A storefront app calls this endpoint to reboot the tenant and increment the security generation. This effectively (since apps should always check for changed security generation) invalidates all OAuth tokens for APIs consumed or produced by this tenant. This is used to mitigate an attack where an app has an OAuth token stolen from it (tenant admin person clicks "Flush credentials" in the storefront).</p><p>The response body is an unguessable unique "launch key" which is then used with POST /tenants/{tenant}/reboots/{launchKey}.</p><p>The core asserts that:</p><ul><li>the app is marked as "storeFront".</li></ul></div><ul class="nav nav-tabs"><li class="active"><a href="#tenants__tenant__OAuthFlushes_post_request" data-toggle="tab">Request</a></li><li><a href="#tenants__tenant__OAuthFlushes_post_response" data-toggle="tab">Response</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tenants__tenant__OAuthFlushes_post_request"><h3>URI Parameters</h3><ul><li><strong>tenant</strong>: <em>required (string)</em></li></ul><h3>Body</h3><p><strong>Type: application/json</strong></p><p><strong>Schema</strong>:</p><pre><code>{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "type": "object",
    "properties": {
       "continuePage": { "type": "string", "description": "the URI that your storefront app thinks the user should be redirected to on patch completion, unless some other storefront app gets installed and hence makes that decision" },
       "bumpSecurityGeneration": { "type": "boolean", "description": "true to request that the tenant&#39;s security generation is incremented as the patch is applied" }, 
       "patchSet": { "$ref": "./patchSet.json"}
       },
       "required": ["patchSet", "bumpSecurityGeneration" ]
}</code></pre><p><strong>Example</strong>:</p><pre><code>{
    "continuePage": "https://storefront.com/apps/zwango",
    "patchSet": [
        {
            "op": "test",
            "path": "status.incarnation",
            "value": 23
        },
        {
            "op": "add",
            "path": "installs",
            "value": {
                "app": "hrsoft-zwango"
            }
        }
    ],
    "bumpSecurityGeneration": false
}
</code></pre></div><div class="tab-pane" id="tenants__tenant__OAuthFlushes_post_response"><h2>HTTP status code <a href="http://httpstatus.es/200" target="_blank">200</a></h2><h3>Body</h3><p><strong>Type: application/json</strong></p><p><strong>Schema</strong>:</p><pre><code>{
	"$schema":"http://json-schema.org/draft-04/schema#",
	"type":"object",
	"additionalProperties":false,
	"properties":{
		"launchKey": { "type": "integer", "description": "an unguessable key used to get information about a previously launched patchSet"}
	},
	"required":[
		"launchKey"
	]
}
</code></pre><p><strong>Example</strong>:</p><pre><code>{
	"launchKey": 40864894563934
}</code></pre></div></div></div></div></div></div></div><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_tenants__tenant__patchSets"><span class="parent">/tenants/{tenant}</span>/patchSets</a> <span class="methods"><a href="#tenants__tenant__patchSets_post"><span class="badge badge_post">post</span></a></span></h4></div><div id="panel_tenants__tenant__patchSets" class="panel-collapse collapse"><div class="panel-body"><div class="list-group"><div onclick="window.location.href = '#tenants__tenant__patchSets_post'" class="list-group-item"><span class="badge badge_post">post</span><div class="method_description"><p>A storefront app calls this endpoint to validate and then prepare a patch document, e.g. to reflect the tenant clicking install on an app.</p><p>The response body is an unguessable unique "launch key" which can be used with POST /tenants/{tenant}/reboots/{launchKey}.</p><p>Pass true for "bumpSecurityGeneration" to force the security generation to be incremented.</p><p>The core asserts that:</p><ul><li>the app is marked as "storeFront".</li></ul></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="tenants__tenant__patchSets_post"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_post">post</span> <span class="parent">/tenants/{tenant}</span>/patchSets</h4></div><div class="modal-body"><div class="alert alert-info"><p>A storefront app calls this endpoint to validate and then prepare a patch document, e.g. to reflect the tenant clicking install on an app.</p><p>The response body is an unguessable unique "launch key" which can be used with POST /tenants/{tenant}/reboots/{launchKey}.</p><p>Pass true for "bumpSecurityGeneration" to force the security generation to be incremented.</p><p>The core asserts that:</p><ul><li>the app is marked as "storeFront".</li></ul></div><ul class="nav nav-tabs"><li class="active"><a href="#tenants__tenant__patchSets_post_request" data-toggle="tab">Request</a></li><li><a href="#tenants__tenant__patchSets_post_response" data-toggle="tab">Response</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tenants__tenant__patchSets_post_request"><h3>URI Parameters</h3><ul><li><strong>tenant</strong>: <em>required (string)</em></li></ul><h3>Body</h3><p><strong>Type: application/json</strong></p><p><strong>Schema</strong>:</p><pre><code>{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "type": "object",
    "properties": {
       "continuePage": { "type": "string", "description": "the URI that your storefront app thinks the user should be redirected to on patch completion, unless some other storefront app gets installed and hence makes that decision" },
       "bumpSecurityGeneration": { "type": "boolean", "description": "true to request that the tenant&#39;s security generation is incremented as the patch is applied" }, 
       "patchSet": { "$ref": "./patchSet.json"}
       },
       "required": ["patchSet", "bumpSecurityGeneration" ]
}</code></pre><p><strong>Example</strong>:</p><pre><code>{
    "continuePage": "https://storefront.com/apps/zwango",
    "patchSet": [
        {
            "op": "test",
            "path": "status.incarnation",
            "value": 23
        },
        {
            "op": "add",
            "path": "installs",
            "value": {
                "app": "hrsoft-zwango"
            }
        }
    ],
    "bumpSecurityGeneration": false
}
</code></pre></div><div class="tab-pane" id="tenants__tenant__patchSets_post_response"><h2>HTTP status code <a href="http://httpstatus.es/200" target="_blank">200</a></h2><h3>Body</h3><p><strong>Type: application/json</strong></p><p><strong>Schema</strong>:</p><pre><code>{
	"$schema":"http://json-schema.org/draft-04/schema#",
	"type":"object",
	"additionalProperties":false,
	"properties":{
		"launchKey": { "type": "integer", "description": "an unguessable key used to get information about a previously launched patchSet"}
	},
	"required":[
		"launchKey"
	]
}
</code></pre><p><strong>Example</strong>:</p><pre><code>{
	"launchKey": 40864894563934
}</code></pre></div></div></div></div></div></div></div><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_tenants__tenant__reboots"><span class="parent">/tenants/{tenant}</span>/reboots</a> <span class="methods"></span></h4></div><div id="panel_tenants__tenant__reboots" class="panel-collapse collapse"><div class="panel-body"><div class="resource-description"><h2 id="about-reboots">About reboots</h2><p>A reboot is the process of TAS performing an orderly shutdown and startup of all of the installed apps for a specific tenant whenever major changes are made to the tenant.</p><p>To play its part correctly when a reboot happens, your app&#39;s control server should produce the reboot APIs. TAS then consumes the following APIs during the reboot.</p><ul><li>/tenants/{}/preHalts</li><li>/tenants/{}/halts</li><li>/tenants/{}/preStarts</li><li>/tenants/{}/starts</li></ul><p>As a reboot happens, TAS maintains a set of history events that the storefront app can use to feed a progress dialogue.</p><h2 id="how-the-storefront-prepares-a-reboot">How the storefront prepares a reboot</h2><p>A reboot is initiated as a result of a tenant&#39;s actions in the storefront app&#39;s UI, specifically;</p><ul><li>when a tenant clicks "install" or "uninstall" on an app, the storefront app calls POST /tenants/{}/patchSets, resulting in a reboot with <a href="../examples/rebootStatus-juggleApps.json">events like these</a>.</li><li>when a tenant clicks "reboot" on their tenant, the storefront app calls POST /tenants/{}/reboots, resulting in a reboot with <a href="../examples/rebootStatus-simpleReboot.json">events like these</a>.</li><li>when a tenant clicks "flush OAuth tokens" on their tenant, the storefront app calls POST /tenants/{}/OAuthFlushes, resulting in a reboot with <a href="../examples/rebootStatus-bumpSecurityGeneration.json">events like these</a>.</li></ul><h2 id="how-the-storefront-launches-a-reboot">How the storefront launches a reboot</h2><p>When the storefront app calls the APIs above, the reboot does not start immediately. Instead, the APIs return a launch key.</p><p>To actually start a reboot, the storefront app (typically from within a web page&#39;s onClick handler of a "Continue" button) uses this launch key to launch the reboot.</p><p>As a reboot happens, TAS maintains the event history, and also a status for;</p><ul><li>the tenant as a whole (see <a href="../schemas/tenantStatus.json">tenant statuses</a>)</li><li>each individual app</li></ul><h2 id="order-of-events-during-reboot">Order of events during reboot</h2><p>During a reboot, the order of events is:</p><ul><li><p>Halt all apps</p><ul><li>TAS sets the tenant&#39;s status to "preHalting"</li><li>TAS calls /tenants/{}/preHalts on each installed app</li><li>When the last app returns 200, TAS sets the tenant&#39;s status to "preHalted"</li><li>TAS sets the tenant&#39;s status to "halting"</li><li>TAS calls /tenants/{}/halts on each installed app</li><li>When the last app returns 200, TAS sets the tenant&#39;s status to "halted"</li></ul></li><li><p>TAS increments tenant.incarnation</p></li><li>TAS performs the actual operation, i.e.:<ul><li>do nothing (if this reboot is in response to a call to POST /tenants/{}/reboots)</li><li>apply the patch set, e.g. to install an app (if this reboot is in response to a call to POST /tenants/{}/patchSets)<ul><li>apps are installed or uninstalled</li><li>routes are adjusted</li></ul></li><li>increment tenant.securityGeneration<ul><li>explicitly (if this reboot is in response to a call to POST /tenants/{}/OAuthFlushes, i.e. the tenant clicked "Flush OAuth tokens"); or</li><li>implicitly (if this reboot is in response to a call to POST /tenants/{}/patchSets and TAS finds that the patch set is making changes to the tenant&#39;s idps or assertion hooks)</li></ul></li></ul></li><li>start all apps<ul><li>TAS sets the tenant&#39;s status to "preStarting"</li><li>TAS calls /tenants/{}/inits on each installed app</li><li>When the last app returns 200, TAS sets the tenant&#39;s status to "preStarted"</li><li>TAS sets the tenant&#39;s status to "starting"</li><li>TAS calls /tenants/{}/starts on each installed app</li><li>When the last app returns 200, TAS sets the tenant&#39;s status to "starting"</li></ul></li></ul></div><div class="list-group"></div></div></div></div><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_tenants__tenant__reboots__launchKey_"><span class="parent">/tenants/{tenant}/reboots</span>/{launchKey}</a> <span class="methods"><a href="#tenants__tenant__reboots__launchKey__post"><span class="badge badge_post">post</span></a></span></h4></div><div id="panel_tenants__tenant__reboots__launchKey_" class="panel-collapse collapse"><div class="panel-body"><div class="list-group"><div onclick="window.location.href = '#tenants__tenant__reboots__launchKey__post'" class="list-group-item"><span class="badge badge_post">post</span><div class="method_description"><p>A storefront app&#39;s web page uses this API to launch a previously prepared reboot (if not already launched), and get the latest events and the current summary details.</p><p>This endpoint is unauthenticated and has CORS headers that allow access from any domain (since the javascript calling it belongs to a storefront app which does not share the same domain as the tas core).</p><p>If the apply is already "complete" then this call will return immediately, with any events that match the filter, up to the maximum events per call (100).</p><p>Otherwise, the call blocks for .5 seconds to avoid thrashing, then returns as soon as at least one event is available that matches the filter, or the apply becomes complete (which would always be accompanied by an event). If no events are available after 60 seconds, the call returns indicating a timeout - the client will typically immediately make another call in a typical long-polling pattern, until the apply is marked as complete and the last event has been fetched.</p></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="tenants__tenant__reboots__launchKey__post"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_post">post</span> <span class="parent">/tenants/{tenant}/reboots</span>/{launchKey}</h4></div><div class="modal-body"><div class="alert alert-info"><p>A storefront app&#39;s web page uses this API to launch a previously prepared reboot (if not already launched), and get the latest events and the current summary details.</p><p>This endpoint is unauthenticated and has CORS headers that allow access from any domain (since the javascript calling it belongs to a storefront app which does not share the same domain as the tas core).</p><p>If the apply is already "complete" then this call will return immediately, with any events that match the filter, up to the maximum events per call (100).</p><p>Otherwise, the call blocks for .5 seconds to avoid thrashing, then returns as soon as at least one event is available that matches the filter, or the apply becomes complete (which would always be accompanied by an event). If no events are available after 60 seconds, the call returns indicating a timeout - the client will typically immediately make another call in a typical long-polling pattern, until the apply is marked as complete and the last event has been fetched.</p></div><ul class="nav nav-tabs"><li class="active"><a href="#tenants__tenant__reboots__launchKey__post_request" data-toggle="tab">Request</a></li><li><a href="#tenants__tenant__reboots__launchKey__post_response" data-toggle="tab">Response</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tenants__tenant__reboots__launchKey__post_request"><h3>URI Parameters</h3><ul><li><strong>tenant</strong>: <em>required (string)</em></li><li><strong>launchKey</strong>: <em>required (string)</em></li></ul><h3>Query Parameters</h3><ul><li><strong>afterEvent</strong>: <em>(integer)</em><p>The sequence of an existing event - this call should return events immediately <em>after</em> this event. Omitting this parameter returns the first events.</p><p><strong>Example</strong>:</p><pre><code>12</code></pre></li></ul></div><div class="tab-pane" id="tenants__tenant__reboots__launchKey__post_response"><h2>HTTP status code <a href="http://httpstatus.es/200" target="_blank">200</a></h2><h3>Body</h3><p><strong>Type: application/json</strong></p><p><strong>Schema</strong>:</p><pre><code>{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "definitions": {
        "app": {
            "type": "string"
        },
        "elapsedTime": {
            "description": "elapsed time of the operation in milliseconds",
            "type": "integer"
        },
        "tenantEvent": {
            "type": "object",
            "additionalProperties": false,
            "required": [
                "kind"
            ],
            "properties": {
                "kind": {
                    "enum": [
                        "patchSetApplyRebootStart",
                        "bumpSecurityGenerationRebootStart",
                        "simpleRebootStart",
                        "tenantPreHaltStart",
                        "tenantPreHaltComplete",
                        "tenantHaltStart",
                        "tenantHaltComplete",
                        "appPatchesApplyStart",
                        "appPatchesApplyComplete",
                        "bumpSecurityGenerationComplete",
                        "tenantPreStartStart",
                        "tenantPreStartComplete",
                        "tenantStartStart",
                        "tenantStartComplete",
                        "patchSetApplyRebootComplete",
                        "bumpSecurityGenerationRebootComplete",
                        "simpleRebootComplete"
                    ]
                }
            }
        },
        "appEvent": {
            "type": "object",
            "additionalProperties": false,
            "required": [
                "kind",
                "app"
            ],
            "properties": {
                "kind": {
                    "enum": [
                        "appPreHaltStart",
                        "appPreHaltComplete",
                        "appHaltStart",
                        "appHaltComplete",
                        "appPreStartStart",
                        "appPreStartComplete",
                        "appStartStart",
                        "appStartComplete",
                        "appInstallComplete",
                        "appUninstallComplete",
                        "appEditComplete"
                    ]
                },
                "app": {
                    "$ref": "#/definitions/app"
                }
            }
        },
        "tenantStatusEvent": {
            "type": "object",
            "additionalProperties": false,
            "required": [
                "kind",
                "incarnation",
                "securityGeneration"
            ],
            "properties": {
                "kind": {
                    "enum": [
                        "tenantStatusEvent"
                    ]
                },
                "incarnation": {
                    "type": "integer"
                },
                "securityGeneration": {
                    "type": "integer"
                }
            }
        },
        "orderedEvent": {
            "type": "object",
            "properties": {
                "seq": {
                    "type": "integer"
                },
                "time": {
                    "type": "string",
                    "format": "date-time"
                },
                "event": {
                    "oneOf": [
                        {
                            "$ref": "#/definitions/tenantEvent"
                        },
                        {
                            "$ref": "#/definitions/appEvent"
                        },
                        {
                            "$ref": "#/definitions/tenantStatusEvent"
                        }
                    ]
                }
            },
            "required": [
                "seq",
                "time",
                "event"
            ],
            "additionalProperties": false
        }
    },
    "type": "object",
    "additionalProperties": false,
    "required": [
        "status"
    ],
    "properties": {
        "status": {
            "enum": [
                "notLaunched",
                "inProcess",
                "complete"
            ]
        },
        "latestEvent": {
            "type": "integer"
        },
        "continuePage": {
            "type": "string",
            "description": "the URI that the browser should redirect the user to once this reboot is complete, possibly at a new storefront if a patch set apply swapped out the current one"
        },
        "events": {
            "type": "array",
            "items": {
                "$ref": "#/definitions/orderedEvent"
            }
        }
    }
}</code></pre><p><strong>Example</strong>:</p><pre><code>{
  "status": "complete",
  "latestEvent": 52,
  "events": [
    {"seq": 0, "time": "2015-11-05T13:15:30Z", "event": {"kind": "patchSetApplyRebootStart"}},
    {"seq": 1, "time": "2015-11-05T13:15:30Z", "event": {"kind": "tenantPreHaltStart"}},
    {"seq": 2, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreHaltStart", "app": "tas-zoom"}},
    {"seq": 3, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreHaltStart", "app": "hrlabs-fratly"}},
    {"seq": 4, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreHaltComplete", "app": "tas-zoom"}},
    {"seq": 5, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreHaltStart", "app": "tas-dummyjobs"}},
    {"seq": 6, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreHaltStart", "app": "tas-uberapply"}},
    {"seq": 7, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreHaltComplete", "app": "hrlabs-fratly"}},
    {"seq": 8, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreHaltComplete", "app": "tas-dummyjobs"}},
    {"seq": 9, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreHaltComplete", "app": "tas-uberapply"}},
    {"seq": 10, "time": "2015-11-05T13:15:30Z", "event": {"kind": "tenantPreHaltComplete"}},
    {"seq": 11, "time": "2015-11-05T13:15:30Z", "event": {"kind": "tenantHaltStart"}},
    {"seq": 12, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appHaltStart", "app": "tas-zoom"}},
    {"seq": 13, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appHaltStart", "app": "hrlabs-fratly"}},
    {"seq": 14, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appHaltComplete", "app": "tas-zoom"}},
    {"seq": 15, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appHaltStart", "app": "tas-dummyjobs"}},
    {"seq": 16, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appHaltStart", "app": "tas-uberapply"}},
    {"seq": 17, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appHaltComplete", "app": "hrlabs-fratly"}},
    {"seq": 18, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appHaltComplete", "app": "tas-dummyjobs"}},
    {"seq": 19, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appHaltComplete", "app": "tas-uberapply"}},
    {"seq": 20, "time": "2015-11-05T13:15:30Z", "event": {"kind": "tenantHaltComplete"}},
    {"seq": 21, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPatchesApplyStart"}},
    {"seq": 22, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appInstallComplete", "app": "tas-tracker"}},
    {"seq": 23, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appInstallComplete", "app": "supersoft-refly"}},
    {"seq": 24, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appEditComplete", "app": "tas-zoom"}},
    {"seq": 25, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appUninstallComplete", "app": "tas-dummyjobs"}},
    {"seq": 26, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPatchesApplyComplete"}},
    {"seq": 27, "time": "2015-11-05T13:15:30Z", "event": {"kind": "tenantPreStartStart"}},
    {"seq": 28, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreStartStart", "app": "tas-zoom"}},
    {"seq": 29, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreStartStart", "app": "hrlabs-fratly"}},
    {"seq": 30, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreStartComplete", "app": "tas-zoom"}},
    {"seq": 31, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreStartComplete", "app": "hrlabs-fratly"}},
    {"seq": 32, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreStartStart", "app": "tas-uberapply"}},
    {"seq": 33, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreStartStart", "app": "tas-tracker"}},
    {"seq": 34, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreStartComplete", "app": "tas-tracker"}},
    {"seq": 35, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreStartStart", "app": "supersoft-refly"}},
    {"seq": 36, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreStartComplete", "app": "tas-uberapply"}},
    {"seq": 37, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appPreStartComplete", "app": "supersoft-refly"}},
    {"seq": 38, "time": "2015-11-05T13:15:30Z", "event": {"kind": "tenantPreStartComplete"}},
    {"seq": 39, "time": "2015-11-05T13:15:30Z", "event": {"kind": "tenantStartStart"}},
    {"seq": 40, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appStartStart", "app": "tas-zoom"}},
    {"seq": 41, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appStartStart", "app": "hrlabs-fratly"}},
    {"seq": 42, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appStartStart", "app": "tas-uberapply"}},
    {"seq": 43, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appStartStart", "app": "tas-tracker"}},
    {"seq": 44, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appStartStart", "app": "supersoft-refly"}},
    {"seq": 45, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appStartComplete", "app": "tas-zoom"}},
    {"seq": 46, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appStartComplete", "app": "hrlabs-fratly"}},
    {"seq": 47, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appStartComplete", "app": "tas-uberapply"}},
    {"seq": 48, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appStartComplete", "app": "tas-tracker"}},
    {"seq": 49, "time": "2015-11-05T13:15:30Z", "event": {"kind": "appStartComplete", "app": "supersoft-refly"}},
    {"seq": 50, "time": "2015-11-05T13:15:30Z", "event": {"kind": "tenantStartComplete"}},
    {"seq": 51, "time": "2015-11-05T13:15:30Z", "event": {"kind": "patchSetApplyRebootComplete"}},
    {"seq": 52, "time": "2015-11-05T13:15:30Z", "event": {"kind": "tenantStatusEvent", "incarnation": 146, "securityGeneration": 10 }}
  ]
}
</code></pre></div></div></div></div></div></div></div></div></div></div><div class="panel panel-default"><div class="panel-heading"><h3 id="token" class="panel-title">/token</h3></div><div class="panel-body"><div class="top-resource-description"><h2 id="about-oauth-tokens">About OAuth tokens</h2><p>API calls between apps (i.e. tenant API calls) are protected by OAuth. The consuming app must obtain an OAuth token from the TAS core, and pass it in the Authorization header when making the API call. For more background on OAuth and tokens, see the [OAuth 2 spec(<a href="http://tools.ietf.org/html/rfc6749">http://tools.ietf.org/html/rfc6749</a>&#39;) and also Google&#39;s <a href="https://developers.google.com/accounts/docs/OAuth2WebServer">OAuth documentation</a> for additional context.</p><p>In TAS, OAuth tokens are scoped by the consuming and producing app, i.e. a single token can be used by an app installed at a tenant (the consuming app) can use to consume any tenant API on a specific app installed at a tenant (the producing app). Currently, producing and consuming tenants are always the same.</p><p>OAuth access tokens in TAS are self-contained security tokens in the form of a JWT (json web token; see <a href="http://jwt.io/">http://jwt.io/</a>). Because access tokens are self-contained and signed, producers can rely on their content without any network traffic to the authorization server (i.e. TAS core).</p><h2 id="on-behalf-tokens">On-behalf tokens</h2><p>Tokens may further be on-behalf, i.e. principal-aware, in which case they also identify some ultimate logged in end user who the API call is on behalf of.</p><h2 id="refresh-tokens">Refresh tokens</h2><p>Some apps need to continue making API calls on behalf of a user, even when the user is no longer logged in.</p><p>Any app that is protected via TAS SSO and is marked as "offlineCapable" (TODO: exact name) can use the urn:ietf:params:oauth:client-assertion-type:saml2-bearer grant type (which requires a SAML assertion), and add the string "offline" to the scope parameter to create an on-behalf OAuth token and an accompanying refresh token. Your app should store the refresh token in its own long-term storage, and can use the access token immediately.</p><p>The access token can be used immediately, and when it expires, the refresh token can be used to generate new access tokens even when the user is no longer logged in.</p><p>Note: you only need to use refresh tokens if the offline activity is on behalf of a specific user. Otherwise your app can just use the client_credentials grant type to request a new OAuth token as soon as the existing one expires.</p><p>Example:</p><pre><code>POST /oauth2/v1/token HTTP/1.1
Host: core.talentappstore.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-bearer
scope=/acme/jobboard/acme/ats%20offline
principal_type=candidate
assertion=kjh9786gJHGutvfUT765Kkjghf70978klhjhgIUYGkpoiygEciYnjOi...
Response:
{
  "access_token":"iuhy76YT785L0GDF23JH7kjhd",
  "expires_in":3600,
  "token_type":"Bearer",
  "refresh_token":"j089777bhkltyHTRFG78969KJH968d"
}
</code></pre><p>Internally, TAS stores a copy of refresh tokens that it has issued, so it can validate requests for new access tokens. These refresh tokens are stored keyed by:</p><ul><li>principal type</li><li>saml key (i.e. the specific SAML assertion that was passed in the "assertion" parameter user identifier (/E/N)</li><li>the SSO-protected app the user logged into (the API consuming app in this case)</li><li>consuming app install</li><li>producing app install</li></ul><p>Your app should save refresh tokens in long-term storage and continue to use them as long as they remain valid. If your app requests another refresh token for the same combination of values above, a new refresh token will be issued and any previous refresh token will be revoked.</p><h2 id="producing-apis-verifying-incoming-oauth-tokens">Producing APIs - verifying incoming OAuth tokens</h2><p>To be secure, when an app receives an incoming tenant API call, it must:</p><ul><li>Check that an incoming OAuth token was provided in the Authorization request header</li><li>Verify that the OAuth token was correctly signed by TAS core, and matches the public key from GET /OAuthKey.</li><li>Check that it is the correct audience (to prevent a malicious app using a token for your app which was intended for another app), i.e.;<ul><li>the "pt" (producing tenant) field matches the current tenant (e.g. as extracted from the Host header)</li><li>the "pa" (producing app) field matches the shortCode hard-coded into the app&#39;s code</li></ul></li><li>call GET /routes/{CT}/{CA}/{PT}/{PA} to verify that a route exists (to prevent a malicious app calling an API on your app which it has not declared that it calls)</li><li>check that whatever method is being used (GET, POST, etc.) is one of the supported methods declare on the API itself</li></ul><p>Because performing the checks above involves making TAS core API calls, the producing app should attempt to cache the results whenever possible.</p><p>For intra-tenant calls (i.e., where the producer and the consumer are the same), the producer can cache route verifications as long as the "sgen" (security generation) parameter in the token matches the app&#39;s own stored value for sgen.</p><p>This works because sgen cannot be changed without bouncing the tenant, and every app is always informed when the tenant is bounced, so the producer always knows it has the latest value for sgen.</p><p>A typical cache implementation might:</p><ul><li>store verification outcomes for intra-tenant calls as booleans in a key value store</li><li>key the outcomes by some synthesised string like /routes/acme/uberapply/acme/ats/tas/%2Fcategories/GET</li><li>flush the cache whenever sgen changes</li></ul><p>For inter-tenant calls (i.e. where the consumer is a remote app likely installed at another tenant), the producer does not receive any notifications when the remote tenant is bounced. Therefore it has no way to maintain an up to date copy of the remote tenant&#39;s sgen value. This means that the producer must verify the route every time. This is not an issue until when/if TAS supports remote mounting.</p></div><div class="panel-group"><div class="panel panel-white"><div class="panel-heading"><h4 class="panel-title"><a class="collapsed" data-toggle="collapse" href="#panel_token"><span class="parent"></span>/token</a> <span class="methods"><a href="#token_post"><span class="badge badge_post">post</span></a></span></h4></div><div id="panel_token" class="panel-collapse collapse"><div class="panel-body"><div class="list-group"><div onclick="window.location.href = '#token_post'" class="list-group-item"><span class="badge badge_post">post</span><div class="method_description"><p>Get a new access token, and optionally a refresh token.</p><p>The request body must be of content-type application/x-www-form-urlencoded, and contain values for grant_type and optionally other parameters, encoded as per <a href="https://tools.ietf.org/html/rfc6749#appendix-B">https://tools.ietf.org/html/rfc6749#appendix-B</a>. See also <a href="https://tools.ietf.org/html/rfc7522#section-4">https://tools.ietf.org/html/rfc7522#section-4</a>.</p><p>The core asserts that:</p><ul><li>the consuming app is installed at the consuming tenant</li><li>the producing app is installed at the producing tenant</li><li>there exists at least one route between the consumer and producer, for any API (this prevents apps probing for the presence of other apps)</li></ul><p>Every call to this endpoint results in a new access token being issued, with an expiry time set to one hour, or (as per <a href="http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithSAML.html">http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithSAML.html</a>) to the time specified in the SAML assertion&#39;s SessionNotOnOrAfter value (if present), whichever is shorter.</p><p>If SessionNotOnOrAfter is in the past then token creation fails, and the app must somehow force the user to reauthenticate.</p><p>For efficiency consumers should cache the tokens returned by this endpoint until (a) the tenant&#39;s security generation number changes, or (b) the cached token is too close to expiry to serve the needs of the consumer.</p></div><div class="clearfix"></div></div></div></div></div><div class="modal fade" tabindex="0" id="token_post"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button><h4 class="modal-title" id="myModalLabel"><span class="badge badge_post">post</span> <span class="parent"></span>/token</h4></div><div class="modal-body"><div class="alert alert-info"><p>Get a new access token, and optionally a refresh token.</p><p>The request body must be of content-type application/x-www-form-urlencoded, and contain values for grant_type and optionally other parameters, encoded as per <a href="https://tools.ietf.org/html/rfc6749#appendix-B">https://tools.ietf.org/html/rfc6749#appendix-B</a>. See also <a href="https://tools.ietf.org/html/rfc7522#section-4">https://tools.ietf.org/html/rfc7522#section-4</a>.</p><p>The core asserts that:</p><ul><li>the consuming app is installed at the consuming tenant</li><li>the producing app is installed at the producing tenant</li><li>there exists at least one route between the consumer and producer, for any API (this prevents apps probing for the presence of other apps)</li></ul><p>Every call to this endpoint results in a new access token being issued, with an expiry time set to one hour, or (as per <a href="http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithSAML.html">http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithSAML.html</a>) to the time specified in the SAML assertion&#39;s SessionNotOnOrAfter value (if present), whichever is shorter.</p><p>If SessionNotOnOrAfter is in the past then token creation fails, and the app must somehow force the user to reauthenticate.</p><p>For efficiency consumers should cache the tokens returned by this endpoint until (a) the tenant&#39;s security generation number changes, or (b) the cached token is too close to expiry to serve the needs of the consumer.</p></div><ul class="nav nav-tabs"><li class="active"><a href="#token_post_request" data-toggle="tab">Request</a></li><li><a href="#token_post_response" data-toggle="tab">Response</a></li></ul><div class="tab-content"><div class="tab-pane active" id="token_post_request"><h3>Body</h3><p><strong>Type: application/x-www-form-urlencoded</strong></p><strong>Form Parameters</strong><ul><li><strong>grant_type</strong>: <em>(string)</em><p>One of:</p><ul><li><strong>client_credentials</strong>: for an anonymous OAuth tokens that is not on behalf of any user/principal. Anonymous tokens are easy to create, but can&#39;t be used to consume on-behalf APIs, which tend to be those with principal-specific logic or security, e.g. only allowing users in the finance department to view account details, logging who the user was who created a job, etc. Anonymous access tokens always expire one hour after they are issued.</li><li><strong>urn:ietf:params:oauth:client-assertion-type:saml2-bearer</strong>: for an on-behalf OAuth token that includes the identity of the user/principal who is the subject of the passed in SAML assertion. This grant type can only be used by apps that are protected via SSO. The token&#39;s expiry time will be either in one hour, or at the time dictated by the original SAML assertion&#39;s "on or before" field (TODO: be specific), whichever is sooner.</li><li><strong>urn:talentappstore.com:oauth:saml2-bearer-key</strong>: As for urn:ietf:params:oauth:client-assertion-type:saml2-bearer, except that the key is used rather than the assertion itself, and this grant type is not restricted to just SSO apps.</li><li><strong>urn:talentappstore.com:oauth:tas-inherited</strong>: for an on-behalf token that re-uses the user&#39;s identity from an incoming on-behalf token. Used by apps that both produce and consume on-behalf APIs; i.e. apps that are intermediate links in a chain of on-behalf API calls. The new access token inherits details of the principal (if any) and the expiry time from the parent access token. This means all access tokens created as part of a nested set of API calls will expire simultaneously.</li><li><strong>refresh_token</strong>:</li></ul><p><strong>Example</strong>:</p><pre>urn:talentappstore.com:oauth:saml2-bearer-key</pre></li><li><strong>scope</strong>: <em>(string)</em><p>A space separated set of values for the OAuth scope of this token, which may include:</p><ul><li>A string starting with "/" that denotes a consuming app installed at a specific tenant and a producing app installed at a specific tenant (MUST be present for all grant types other than refresh_token)</li><li>the keyword "offline" (MAY be present only when grant_type is urn:ietf:params:oauth:client-assertion-type:saml2-bearer)</li></ul><p><strong>Example</strong>:</p><pre>/acme/jobboard/acme/ats offline</pre></li><li><strong>principal_type</strong>: <em>(string)</em><p>The principal type the on-behalf token is being created for. MUST be present when grant_type is urn:ietf:params:oauth:client-assertion-type:saml2-bearer or urn:talentappstore.com:oauth:saml2-bearer-key. MUST NOT be present for other grant types.</p><p><strong>Example</strong>:</p><pre>candidate</pre></li><li><strong>refresh_token</strong>: <em>(string)</em><p>A refresh token obtained via a previous call to this endpoint with scope of offline. MUST be present when grant_type is refresh_token. MUST NOT be present for other grant types.</p></li><li><strong>parent_token</strong>: <em>(string)</em><p>An access token passed in to the consuming app. MUST be present when grant_type is urn:talentappstore.com:oauth2:tas-inherited. MUST NOT be present for other grant types.</p></li><li><strong>assertion</strong>: <em>(string)</em><p>The incoming SAML assertion. MUST be present for grant_type of urn:ietf:params:oauth:client-assertion-type:saml2-bearer. MUST NOT be present for other grant types. MUST contain an unexpired SAML assertion that matches exactly one as captured and stored by the TAS SAML proxy during login <em>to the same app making the core-in API call</em>.</p></li><li><strong>samlKey</strong>: <em>(string)</em><p>A reference to the incoming SAML assertion. MUST be present for grant_type of urn:talentappstore.com:oauth:saml2-bearer-ref. MUST NOT be present for other grant types. MUST contain a valid reference to an unexpired SAML assertion as captured and stored by the TAS SAML proxy during login <em>to the same app making the core-in API call</em>.</p></li></ul></div><div class="tab-pane" id="token_post_response"><h2>HTTP status code <a href="http://httpstatus.es/200" target="_blank">200</a></h2><h3>Body</h3><p><strong>Type: application/json</strong></p><p><strong>Schema</strong>:</p><pre><code>{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "type": "object",
    "additionalProperties": false,
    "description": "result of a call to POST /token",
    "properties": {
        "access_token": {
            "type": "string",
            "description": "the token (a JWT signed by the core and with the structure described in the schema tokenJwt.json)"
        },
        "expires_in": {
            "type": "integer",
            "description": "The remaining lifetime of the access token, in seconds"
        },
        "token_type": {
            "enum": [
                "Bearer"
            ]
        },
        "refresh_token": {
            "type": "string",
            "description": "An optional refresh token, when the response was a result of a call to POST /token with scope of offline"
        }
    },
    "required": [
        "access_token",
        "expires_in",
        "token_type"
    ]
}</code></pre><p><strong>Example</strong>:</p><pre><code>{
  "access_token":"iuhy76YT785L0GDF23JH7kjhd",
  "expires_in":3600,
  "token_type":"Bearer",
  "refresh_token":"j089777bhkltyHTRFG78969KJH968d"
}</code></pre></div></div></div></div></div></div></div></div></div></div></div><div class="col-md-3"><div id="sidebar" class="hidden-print affix" role="complementary"><ul class="nav nav-pills nav-stacked"><li><a href="#apps">/apps</a></li><li><a href="#OAuthKey">/OAuthKey</a></li><li><a href="#patchSets">/patchSets</a></li><li><a href="#ping">/ping</a></li><li><a href="#routes">/routes</a></li><li><a href="#saml">/saml</a></li><li><a href="#tenants">/tenants</a></li><li><a href="#token">/token</a></li></ul></div></div></div></div></body></html>