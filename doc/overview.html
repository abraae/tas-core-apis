<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<!-- always required -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>

<!-- needed for sequence diagrams -->
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/raphael-min.js'></script>
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/underscore-min.js'></script>
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/sequence-diagram-min.js'></script>
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/sequence-diagram-wrapper.js'></script>

<!-- needed for includes -->
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/clientInclude.js'></script>

<!-- needed for table of contents -->
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/tocify.js'></script>

<link rel="stylesheet" href="//normalize-css.googlecode.com/svn/trunk/normalize.css" />

<!-- always required -->
<link rel='stylesheet' href='http://talentappstore.github.io/tas-des-static/css/des.css' type='text/css' media='all' />

<title>Talent App Store app developer guide</title>
</head>
<body>


<h1>Talent App Store app developer guide</h1>

<p>Please send comments to abraae@talentappstore.com.</p> 

<div id="toc"></div>


<h1>External documents</h1>

<ul>
<li><a href='../index.html'>Core API documentation</a> (RAML and JSON Schema)
<li>tas-core-apis on <a href='https://github.com/talentappstore/tas-core-apis'>GitHub</a>
</ul>
              
<h1>Overview</h1>


<p>Talent App Store is an HR Saas platform for microservices.</p>

<p>Tenants (i.e., customers) can click to install small, pre-integrated
HR web applications that present to the user within a "single pane of glass"..</p>

<h1>Benefits of TAS</h1>

<p>To you, as the developer of a talent management app, Talent App Store brings you these benefits:

<dl>

<dt>A sales channel</dt>
<dd>Hundreds of customers are able to use TAS, making thousands of API
endpoints available. If you have a product that solves some talent management problem better
than anyone else, you now have access to a ready market of people who can provision your product
with a single click.
</dd>

<dt>Rock solid security</dt>
<dd>One of the hardest aspects of selling HR software to enterprises is addressing the
IT team's security demands. In TAS, your app runs within an industry standard
security and identity framework, using technologies like SSO via SAML, OAuth and others.
TAS handles all of the heavy lifting of security for you, frees you from the
risky business of managing user authentication, and allows you to make binding guarantees
to customers about the safety of their data within your app. 
</dd>

<dt>A demo packaging service</dt>
<dd>With TAS, you can define shopping lists of microservices
that support your app, such as databases of demo jobs, org structures, and wrap these around
your app. Customers can install your app as a part of a complete, functioning technology stack,
trial it, and then swap out the demo apps in the stack for real apps connected to their existing
talent management platform.
</dd>

</dl>


<h1>How it works</h1>

<ul>

<li><b>TAS is a provisioning service.</b> TAS calls an API on your app to tell you in real time
when new tenants install or uninstall your app. You respond to the provisioning API by
inserting a row into your customer table, assigning a trained simian to start
installing a server, or whatever.

<li><b>An SSO (Single Sign On) service.</b> If your app presents a web user interface,
then TAS handles logins to your app in a highly secure, customer-controlled way, and
integrates tightly with customer-supplied identity providers via SAML 2.0. SAML support
and SSO is increasing understood by customers to be a key part of an integrated talent
management experience.

<li><b>An API directory service.</b> TAS provides APIs for your app to dynamically
locate API endpoints on other apps, based on the tenant's latest installation choices.
For example, your app simply locates and then calls the GET /jobs endpoint, without
needing to know which app is currently producing that endpoint. If the customer swaps
out their ATS and replaces it with another, your app continues calling GET /jobs without interruption.

<li><b>An API authentication service.</b> TAS provides access tokens and credentials for
apps to call each others APIs securely, with user identity available to all endpoints.

<li><b>An app lifecycle service.</b> TAS sends your app tenant-specific signals so
that it can  shut down and start up cleanly as tenants make changes to their
configuration (e.g. installing and uninstalling apps).


</ul>


<h1>What its not</h1>

<p>There are some things that TAS is not:
<ul>
<li>TAS is not an IaaS or a hosting platform. You host your apps yourself
on your own infrastructure.

<li>TAS is not a programming language or a framework. You can write your apps
in your language of choice, using whatever user interface framework you favour
and storing your data in your chosen database. TAS helps you to communicate
with other apps, and with TAS itself, via http-based REST APIs. TAS does
provide a set of Java client libraries to help with writing apps.

<li>TAS is not an ESB (Enterprise Service Bus). API traffic does not flow through
any TAS servers. Instead, your app uses TAS to locate an API endpoint and obtain
an access token. The actual API call is made directly from your app (the consumer)
to the other app (the producer) over the internet, and not through TAS. TAS is
not a bottleneck or a point of failure.
</ul>

<h1>How it works</h1>

<h2>Multitenant architecture</h2>

[diagram]


<h1>API types in TAS</h1>

<p>Within a single tenant, most of the action takes place when apps call APIs on other apps. We call these <b>tenant APIs</b>.
As much as possible, TAS helps apps get set up to make tenant API calls to each other, then stays out of the way.</p>

<p>Tenant APIs are business-oriented, like fetching the current list of open jobs.</p>

<p>TAS itself also provides some <b>core APIs</b> that support meta functionality, like notifying your app that it has a new
tenant, stopping and starting apps, locating API endpoints, etc.</p>

<p>Core API calls are either inwards (where your app calls an endpoint on TAS) or
outwards (where TAS calls an endpoint on the <b>control server</b> of your app).</p>

<b>Core and tenant APIs in Talent App Store</b>
<div class='seqDiag' id="apitypes">
participant TAS
participant ATS app
participant Career site app
participant Social sharing app
TAS->ATS app: outwards core API, e.g. stop tenant, start tenant,\nadd tenant, delete tenant
TAS->Career site app:
TAS->Social sharing app:
ATS app->TAS: inwards core API, e.g. locate API endpoint,\nobtain access token, signal shutdown complete
Career site app->TAS:
Social sharing app->TAS:
Career site app->ATS app:tenant API call, e.g. GET /openJobs
Social sharing app->ATS app:tenant API call, e.g. GET /openJobs/{id}
</div>


<h2>Tenant APIs</h2>

<p>Tenant APIs are made from one app (the <b>consumer</b>) in the store to another (the <b>producer</b>).</p>

<p>For example, a job board app might call <b>GET /jobs</b> to obtain a list of currently open jobs.</p>

<p>Tenant API calls are always within the context of a single tenant. An app working on behalf of one tenant can never make a tenant API call to an app working on behalf of a diferent tenant. TAS provides no facilities for communicating between tenants.</p> 

<h3>Tenant API transport</h3>

<p>Tenant API calls flow directly from one app to another over the internet, and do not pass through TAS itself.
Once the consumer and producer are set up, any number - even thousands - of tenant API calls can be made without any traffic to TAS itself,
and without the need for any TAS API calls. This makes TAS extremely scalable and resilient, and greatly reduces the chance of TAS
becoming a bottleneck or point of failure.</p>

<h3>Tenant API namespacing</h3>

<p>TAS is an open, vendor-neutral platform where all apps are equal, and where any tenant API can be produced or consumed by any app.</p>

<p>Any developer is free to add their own tenant APIs to TAS (subject to the TAS terms of service, which are designed to maintain the
system's integrity, rather than to favour any one developer).
There is no central authority that vets API names, checks for collisions, or otherwise enforces consistency on API naming.</p>

<p>It follows that more than one developer may want to define, say, the /jobs API.</p>

<p>Rather than using a "first in, first served" system, which would be vulnerable to name squatting, in TAS all tenant APIs are
identified not just by their URI, but also by the name of the developer who defined the API. This means there may be multiple
<b>/jobs</b> APIs defined, e.g.:
<ul>
<li><b>&lt;tas&gt;/jobs</b> (defined by Talent App Store Ltd)
<li><b>&lt;smartsoft&gt;/jobs</b> (defined by SmartSoft Corp.)
<li><b>&lt;acme-int&gt;/jobs</b> (defined by Acme Corp.)
</ul>
</p>

<p>In some examples you may see the developer omitted for brevity. But it is always required, i.e. an app does not simply call <b>GET /jobs</b>, it specifically calls <b>GET &lt;tas&gt;/jobs</b>,
or <b>GET &lt;smartsoft&gt;/jobs</b> or whatever.</p>


<h3>TAS is decentralized</h3>

<p>TAS is designed as an entirely decentralized platform. When your app consumes a tenant API, it cannot know by itself which app()s) are producing that API,
because this depends on which apps the tenant currently has installed.</p>

<p>This is quite different to the APIs that you might find provided by a large vendor's system, when
an API call is always either to, or sometimes from, the mothership.</p>

<p>In TAS, there is no mothership. All apps are equal. Any app can produce any API, and any app can consume any API on any other app.
It is even a contractual requirement that any developer defining an API in TAS releases the API under a suitable open source license. The purpose
of this is to minimise any legal impediments to a customer swapping out an app for another that produces the same APIs.</p>

<p>This decentralization is deliberate, with the purpose of giving customers choice, preventing lock-in and making them masters of their own destiny by allowing
them to swap out any app and replace it with another one.</p>


<h3>Locating tenant API endpoints</h3>

<p>The flip side of decentralization is that your app has no way to know how to call GET /jobs, since it does not know which app the
customer (tenant) has installed to produce that API.</p>

<p>Therefore, before calling a tenant API for the first time, your app must use a core API to ask TAS how to make the call.</p>

<p>If your app is written in Java, you will probably use the TAS Java client libraries to hide this complexity (and to provide efficiencies
such as caching endpoint locations and access tokens for as long as possible, clearning them down when the app is cycled, etc.).</p>

<p>However for clarification the process of calling a tenant API is shown below at the raw API level. In this example:
<ul>
<li>On behalf of the tenant acme;
<li>the app "jobsite" wants to call GET &lt;tas&gt;/jobs to get the list of currently open jobs;
<li>GET &lt;tas&gt;/jobs is currently produced by the app "ats";
<li>The ats app uses HMAC authentication for the GET &lt;tas&gt;/jobs API (not basic)
</ul>
</p>

<p>Note: in practice routes should be cached to minimise traffic. Once cached, none of the core API calls shown above would be needed.</p>


<b>Sequence of events - one app calling an HMAC tenant API on another app</b>
<div class='seqDiag' id="callingAnApi">
participant TAS
participant jobsite app
participant ats app
jobsite app->TAS: GET /acme/routes/jobsite/tas/%2Fjobs
note right of TAS: Response:\n"producer": "ats",\n"location": "https://acme.ats.com:2109/api",\n"auth": { "kind": "hmacAuth",\n"hmacCredentials": { "signingKey": "k8763216548hppou"\n                
jobsite app->ats app: GET https://acme.ats.com:2109/api/jobs
note left of ats app: ats app examines the incoming Authorization\nheader and sees that jobsite app is making the\ncall, needs to ask TAS for signing key 
ats app->TAS: GET /acme/routes/jobsite/tas/%2Fjobs/ats
note right of TAS: Response:\n...\n"auth": { "kind": "hmacAuth",\n"hmacCredentials": { "signingKey": "k8763216548hppou"\n                
note left of ats app: ats verifies HMAC and allows the API call 
</div>


<h3>Tenant API versioning</h3>

<p>The developer who owns a tenant API is in control of that API's definition.</p>

<p>For example, the developer may choose to add an additional field to the APIs response body.</p>

<p>However any changes to an API definition should be made in a non-breaking style.
The following are guidelines as to what this means 
(with thanks to <a href='https://wiki.openstack.org/wiki/APIChangeGuidelines'>openstack</a>):</p>

<h4>Generally acceptable</h4>
<ul>
<li>The change is the only way to fix a security bug
<li>Fixing a bug so that a request which resulted in an error response before is now successful
<li>Adding a new response header
<li>Changing an error response code to be more accurate
<li>Adding a property to a resource representation
<li>Adding an optional property to a resource representation which may be supplied by clients, assuming the API previously would ignore this property
</ul>
<h4>Generally not acceptable</h4>
<ul>
<li>A change such that a request which was successful before now results in an error response (unless the success reported previously was hiding an existing error condition)
<li>Changing or removing a property in a resource representation
<li>Changing the semantics of a property in a resource representation which may be supplied by clients
<li>Changing or removing a response header
<li>Changing which response code is returned on success
</ul>

<p>If it is essential that a non-breaking change is made, the owner of the API should instead define a new tenant API.</p>

<h3>Ownership vs use of tenant APIs</h3>

<p>While owning a tenant API gives a developer control over the APIs, it does not provide any contol over who uses the API.
Any developer is free to build an app that produces or consumes any API.<p>

<p>For customers, this provides assurance that they can swap out apps and replace them if they need to
(assuming that a replacement app that produces the same APIs is available).</p>

<p>For developers of apps that consume APIs, this means not being commercially at the mercy of dependant on a single, larger entity.
For example, as the developer of a job board, you can just consume GET &lt;tas&gt;/jobs, without caring which application tracking system
(or any otehr source of open jobs) the tenant has installed. If the tenant swaps out their ATS, your app will keep working, without
any changes.</p> 

<p>As a developer, you are also free to define all your own APIs, rather than use any defined by other developers. Since you own
the APIs, and the apps, this gives you complete control over your own destiny. Of course, unless you can persuade other developers
to also use your APIs, your apps will effectively be an island (or an island chain).</p>  

<h3>Source of Truth APIs</h3>   

<p>In a talent management ecosystem based on microservices, each type of business object such as jobs or job seekers
"belongs" to some app that acts as the single source of truth, aka the master record. That master record app produces API endpoints like GET /jobs
or GET /jobSeekers through which other apps can learn about the definitive set of business objects for a given customer (tenant).<p>

<p>In TAS, tenant APIs like this are called Source of Truth (SoT) APIs. Most tenant APIs are SoT APIs.</p>

<p>Only one app can produce a given SoT API at any one time.</p>

<p>As an app developer, SoT APIs are easier to deal with. If is only one source of truth for jobs, its easy for other apps
to search jobs, report on them and generally manipulate them. An app only has to go to one known place for example to fetch
all open jobs for the tenant.</p>

<p>When an app is installed by a tenant, TAS checks that the app does not violate any SoT APIs. For example, if an app
is installed that produces /jobs, TAS will not allow another app to be installed that also produces /jobs.</p>

<h4>Non-Source of Truth APIs</h4>   

<p>Some tenant APIs are not SoT APIs.</p>

<p>For example, maybe the app holding the definitive set of open jobs needs an API that it can call to alert other
apps that a new job has been posted (this example uses the simple replication convention described elsewhere for its API
signatures).</p>

<p>To do this, the "job master record" app would by convention call an API like this, on every app that wished to be alerted about new jobs:</p>

<div class='codeBlock'>
POST /m/jobs/{}/deltaPings 
</div> 

<p>Because the URI of this API begins with the special sequence "/m" (short for "many"), TAS treats the API as a non-SoT API.</p>

<p>Unlike an app producing a SoT API, TAS will allow any number of apps to be installed that all produce the same non-SoT API.
So if the tenant wants to use 6 separate apps that all keep their own local copy of open jobs (a likely reason why they would
want to be alerted about new open jobs), TAS will allow them all to be installed at the same time.</p>

<p>Consuming non-SoT APIs is harder work for the app  developer.</p>

<p>For example, in the case above, when new job 10223 is created, what happens if the calls to POST /m/jobs/10223/deltaPings
succeeds for the first 2 producing apps, but then fails for the third? Should the app continue on POST-ing to the
remaining 3 apps? These types of questions are harder to answer when an app is consuming an endpoint on many producers.</p>


<h1>Consuming APIs</h1>

<h2>Fetch the route(s) for the API</h2>

<p>The first step in calling an API is to fetch the route(s) for it.</p>

<p>A route is a usage of a specific tenant API, on a specific producing app installed at the producing tenant,
by a specific consuming app installed at the consuming tenant.</p>

<p>For example:
<ul>
<li>the app "ats"
<li>by the developer "smartyhr"
<li>and installed by the tenant "acme"
<li>wants to make a GET call to every app that produces
<li>the API "/categories"
<li>as defined by the developer "tas"
</ul>
</p>

<p>To fetch the routes (plural since this is non-SoT), the ats app calls:

<div class='codeBlock'>
GET /routes/acme/smartyhr/ats/tas/%2Fcategories/false

Response:
<div class='clientInclude' data-href='../examples/routes-simple.json'></div>
</div>
</p>

<p>From the response, the smartyhr-ats app can see that acme has installed two apps that
produce /categories. The response also includes the physical endpoint details.
</p>

<p>The smartyhr-ats app wants to make an API call to the first producer, the greenjobs-gjcore app.
</p>


<h2>Obtain an OAuth access token</h2>

<p>In TAS, tenant API calls are OAuth protected, which means the consumer of the API needs to obtain 
an OAuth token and then pass it in the Authorization header of the API call.
</p>

<p>TAS supports several different ways to obtain an OAuth access token.
</p>

<p>For more background on OAuth and tokens, see the <a href='http://tools.ietf.org/html/rfc6749'>OAuth 2 spec</a>
and also Google's <a href='https://developers.google.com/accounts/docs/OAuth2WebServer'>OAuth documentation</a> for additional context.
</p>


<h3>Obtaining an anonymous token</h3>

<p>Anonymous OAuth tokens are used to make API calls that are not specific to any particular principal (user).
</p>

<p>Any app that consumes an API can use the "urn:talentappstore.com:oauth2:tas-direct" grant type to
create an anonymous OAuth token.
</p>

<p>In this example:
<ul>
<li>the second route for the /categories API leads to the app "gjcore", installed at the tenant "greenjobsite"
<li>the ats app's business logic is such that it wants to call the /categories API using an anonymous OAuth token.
</ul>
</p>

<p>In TAS, OAuth tokens are scoped by the combination of the consuming app install and the producing app install.
Therefore the app starts by composing a string specifying the "from" and "to" installed apps:

<div class='codeBlock'>
/acme/smartyhr/ats/greenjobsite/greenjobs/gjcore
</div>
</p>

<p>The ats app can now fetch the an anonymous OAuth token via a call to the token endpoint:

<div class='codeBlock'>
POST /oauth2/v1/token HTTP/1.1
Host: core.talentappstore.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn%3Atalentappstore.com%3Aoauth2%3Atas-direct
scope=/acme/smartyhr/ats/greenjobsite/greenjobs/gjcore
</div>
</p>

<p>TAS issues a new access token and passes it back. Anonymous access tokens created by TAS
always expire one hour after they are issued.

<div class='codeBlock'>
Response:
{
  "access_token":"1/fFAGRNJru1FTz70BzhT3Zg",
  "expires_in":3600,
  "token_type":"Bearer",
}
</div>
</p>

<p><b>Note:</b> the client credentials described in the OAuth 2 spec do not need to be passed in
the call to GET /token, as all TAS core API calls are secured via HMAC which securely
identifies the client (i.e. the consuming app).
</p>

<p>With an anonymous token, the API producer can't apply any principal-specific logic or security
(e.g. only allowing users in the finance department to view account details, or logging
on the server who the user was who created a job, etc.).
</p>

<h3>Obtaining a principal-aware token</h3>

<p>Another type of OAuth token is a principal-aware token. While its easy for apps to create anonymous
OAuth access tokens, some APIs behave differently or will only work with a principal-aware OAuth token,
i.e. one that embeds information about a specific user.
</p>

<p>Any app that consumes an API and is protected via TAS SSO can use the "urn:talentappstore.com:oauth2:tas-direct"
grant type along with the entityID and nameID parameters to create a principal-aware OAuth token.
</p>

<p>In this example, the ats app could create a principal-aware OAuth token like this:

<div class='codeBlock'>
POST /oauth2/v1/token HTTP/1.1
Host: core.talentappstore.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn%3Atalentappstore.com%3Aoauth2%3Atas-direct
scope=/acme/smartyhr/ats/greenjobsite/greenjobs/gjcore
entityID=idp3.acme.com
nameID=fredbloggs1123
</div>
</p>

<p>TAS creates a new access token which has the principal's entity ID and name ID embedded
within it, and and passes it back.
</p>

<p>The tokens expiry time will be either in one hour, or at the time dictated by the original SAML
assertion's "on or before" field (TODO: be specific), whichever is sooner.

<div class='codeBlock'>
Response:
{
  "access_token":"1/Gthf5RhgIUvfKUY684578hT3Zg",
  "expires_in":1533,
  "token_type":"Bearer"
}
</div>
</p>

<h3>Obtaining a refresh token for offline use</h3>

<p>Some apps need to continue making API calls on behalf of a user, even when the user is no longer logged in.
</p>

<p>Any app that consumes an API and is protected via TAS SSO and is marked as "offline capable" (TODO:
exact name) can use the "urn:talentappstore.com:oauth2:tas-direct" grant type to create a
principal-aware OAuth token and an accompanying refresh token.
</p>

<p>The access token can be used immediately, and when it expires, the refresh token can be used to generate new
access tokens even when the user is no longer logged in.
</p>

<p>The token request is the same as ordinary principal-aware request, except that the app adds
the keyword "offline" to the scope parameter.

<div class='codeBlock'>
POST /oauth2/v1/token HTTP/1.1
Host: core.talentappstore.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn%3Atalentappstore.com%3Aoauth2%3Atas-direct
scope=/acme/smartyhr/ats/greenjobsite/greenjobs/gjcore%20offline
entityID=idp3.acme.com
nameID=fredbloggs1123
</div>
</p>

<p>The response contains a refresh token alongside the usual access token. Your app should
store the refresh token in its own long-term storage.

<div class='codeBlock'>
Response:
{
  "access_token":"iuhy76YT785L0GDF23JH7kjhd",
  "expires_in":3600,
  "token_type":"Bearer",
  "refresh_token":"j089777bhkltyHTRFG78969KJH968d"
}
</div>
</p>

<p><b>Note:</b> internally, TAS stores a copy of refresh tokens that it has issued, so it can validate
requests for new access tokens. These refresh tokens are stored keyed by:
<ul>
<li>user identifier (/E/N)
<li>the SSO-protected app the user logged into (the API consuming app in this case)
<li>consuming app install
<li>producing app install
</ul>
</p>

<p>You should save refresh tokens in long-term storage and continue to use them as long as they
remain valid. If your application requests another refresh token for the same combination of
user, app and app route as described above, a new refresh token will be issued and any previous
refresh token will be revoked.
</p>

<p><b>Note:</b> you only need to use refresh tokens if the offline activity is on behalf of a specific user. Otherwise
your app can simply request a new anonymous OAuth token as soon as the existing one expires.
</p>

<h3>Obtaining an access token using a refresh token</h3>

<p>Some apps need to continue making API calls on behalf of a user, even when the user is no longer logged in.
</p>

<p>Any app that has obtained both an access token and a refresh token (via a prior call to the
token endpoint with scope of "offline") can use the "refresh_token" grant type to create a new access token
once the original access token expires.
</p>

<p>In this way, an app can continuously generate access tokens and act on behalf of a principal, even when that
user may be no longer logged in.
</p>

<p>The token request is as follows:

<div class='codeBlock'>
POST /oauth2/v1/token HTTP/1.1
Host: core.talentappstore.com
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token
refresh_token=j089777bhkltyHTRFG78969KJH968d

Response:
{
  "access_token":"iuhy76jhbitypLIUhLKkdlkjdnd23JH7kjhd",
  "expires_in":3600,
  "token_type":"Bearer"
}
</div>
</p>

<p>Access tokens created via a refresh token always have an expiry of one hour.</p>

<h3>Obtaining an access token from an incoming access token</h3>

<p>Some apps that are API producers in turn consume other APIs, i.e. they are an intermediate link in a chain of API calls.
</p>

<p>Any app that is an API producer can use the grant type "urn:talentappstore.com:oauth2:tas-inherited"
with the parameters parent_token and scope to generate a new access token.
</p>

<p>As when generating an anonymous token, the consuming app starts by composing a string specifying the "from"
and "to" installed apps, e.g. in this example where the gjcore app consumes an API on the gjrefcodes app:

<div class='codeBlock'>
/greenjobsite/greenjobs/gjcore/greenjobsite/greenjobs/gjrefcodes/
</div>
<p>

<p>The gjcore app can now request an OAuth token via a call to the token endpoint:

<div class='codeBlock'>
POST /oauth2/v1/token HTTP/1.1
Host: core.talentappstore.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn%3Atalentappstore.com%3Aoauth2%3Atas-inherited
scope=/acme/smartyhr/ats/greenjobsite/greenjobs/gjcore
parent_token=iuhy76jhbitypLIUhLKkdlkjdnd23JH7kjhd
</div>
</p>

<p>TAS issues a new access token and passes it back.
</p>

<p>The new access token inherits details of the principal (if any) and the expiry time 
from the parent access token. This means all access tokens created as part of a nested set
of API calls will expire simultaneously.

<div class='codeBlock'>
Response:
{
  "access_token":"1/fFAGRNJru1FTz70BzhT3Zg",
  "expires_in":2012,
  "token_type":"Bearer",
}
</div>
</p>

<h2>Calling the API</h2>

<p>Once an access token is obtained, the app can now make the API call, by embedding the OAuth token
in the http Authorization field, for example:

<div class='codeBlock'>
POST /v1/categories HTTP/1.1
Host: api.greenjobs.co.nz
Content-Type: application/json
Authorization: Bearer 1/fFAGRNJru1FTz70BzhT3Zg
</div>
</p>


<h2>Caching of tokens by consumers</h2>

<p>Consuming apps should cache access tokens rather than requesting new tokens for every API call they make.</p>


<h2>Revoking a refresh token</h2>

<p>To programmatically revoke a refresh token, your app makes a request to the revoke endpoint that
includes the refresh token as a parameter:

<div class='codeBlock'>
https://core.talentappstore.com/oauth2/v1/revoke?token={token}
</div>
</p>

<p>TODO: add to corein.raml</p>

<p>Revoking a refresh token does not revoke any associated access tokens (TAS does not store access tokens).
</p>

<h2>Incrementing the security generation</h2>

<p>In the event of a security breach, a tenant may want to perform a bulk revocation of SAML
assertions, TAS sessions and refresh and access tokens.
</p>

<p>This has the effect of forcing all principals at the tenant to log in again. Apps that perform
background or batch operations will need to obtain new refresh tokens.
</p>

<p>TODO: complete</p>


<h1>Producing an API</h1>

<p>The first step in producing a tenant API is to verify that the incoming OAuth token (found in
the Authorization header) is valid and appropriate.
</p>

<p>OAuth access tokens in TAS are JWTs, signed by TAS. They are self-contained, and can be examined
and verified by the consuming app without any communication with TAS itself.
</p>

<p>The examples below assume that the incoming API call has arrived at the "GET /categories" (an API defined by
developer "tas") endpoint on the producing app.
</p>

<h2>Check the integrity of the token</h2>

<p>Decode and perform a cryprographic check that the JWT was issued indeed by TAS and has not been tampered with.
</p>

<p>[TODO: flesh out]
</p>

<p>Once decoded, an OAuth access token (in this case the presence of the sub field
shows this token is principal-aware) will look something like this:

<div class='codeBlock'>
{
    "sub": {
        "entityID": "ibmidpuswest-10",
        "nameID": "frank@ibm.com"
    },
    "cons": {
        "ct": "acme",
        "cad": "tas",
        "ca": "uberapply",
        "sgen": 219
    },
    "aud": {
        "pt": "acme",
        "pad": "hrsoft",
        "pa": "ats",
        "sgen": 12
    },
    "iat": "31 Dec 2014",
    "exp": "31 Dec 2014"
}
</div>
</p>

<h2>Audience checks</h2>

<p>The producing app MUST check that it is the correct audience, i.e.:

<ol>
<li>The "pt" (producing tenant) field must match the current tenant (i.e. as extracted from the incoming request)
<li>The "pad" (producing app developer) and "pa" (producing app) fields must match the values hard-coded into this app
</ol>

<p>This check prevents a malicious app using a token for your app which was intended for another app.
</p>


<h3>API checks</h3>

<p>The producing app MUST check that the API call being made is allowed, i.e. that:

<ul>
<li>a route exists from the consuming app install to the producing app install
<li>a valid method is being used (GET, POST, etc.)
</ul>
</p>

<p>This prevents a malicious app calling an API on your app which it has not declared that it calls.
</p>

<p>For example, using the data from the access token above (the "aud" field contains the producer details, so named
for consistency with the JWT spec), the producing app would concatenate details of its own endpoint to the from
and to details from the token to make the core API call:

<div class='codeBlock'>
GET /routes/acme/tas/uberapply/acme/hrsoft/ats/tas/%2Fcategories
</div>
</p>

<p>Note the endpoints should be unaware of whether they are being called as SoT or non-SoT. The call
above will return the route details if it exists as either SoT or non-SoT (API consumption by an
app must be one or the other but not both).

<div class='codeBlock'>
Response:
<div class='clientInclude' data-href='../examples/route-simple.json'></div>
</div>

<p>A return code of 200 means that the route exists and is currently valid.
</p>

<p>Finally the producing app should check that the method being used is one of the methods declared:
<ul>
<li>by the consuming app as being consumed
<li>by the producing app as being produced
</ul>

<p>In this case, the incoming call was to "GET /categories", and GET is supported by the producer and
declared as consumed by the consumer, so the test passes.
</p>

<h2>Caching API check results</h2>

Because API checks as described above involve making TAS core API calls, the producing app should
attempt to cache the results whenever possible.

<h3>Intra-tenant API calls</h3>

<p>For intra-tenant calls (i.e., where the producer and the consumer are the same), the
producer can cache route verifications as long as the "sgen" (security generation) parameter
in the token matches the app's own stored value for sgen.
</p>

<p>This works because sgen cannot be changed without bouncing the tenant, and every app is always
informed when the tenant is bounced, so the producer always knows it has the latest value for
sgen.
</p>

<p>A typical cache implementation might:
<ul>
<li>store verification outcomes for intra-tenant calls as booleans in a key value store
<li>key the outcomes by something like /routes/acme/tas/uberapply/acme/hrsoft/ats/tas/%2Fcategories/GET
<li>flush the cache whenever sgen changes
</ul>

<h3>Inter-tenant API calls</h3>

<p>For inter-tenant calls (i.e. where the consumer is a remote app likely installed at another tenant),
the producer does not receive any notifications when the remote tenant is bounced. Therefore it
has not way to maintain an up to date copy of the remote tenant's sgen value.
</p>

<p>This means that  current has no way to know that a reconfiguration has not happened at the remote consumer,
and so has to verify the route every time.
</p>


<h1>Principal types and roles</h1>

<p>A principal type is a class of person (or system) that can:
<ul>
<li>log into an TAS SSO-protected app
<li>indirectly call an OAuth protected TAS tenant API
</ul>
</p>

<p>Any TAS app that is SSO-protected or that produces OAuth APIs needs to do so within the context of a specific principal type.</p>

<p>For example:
<ul>
<li>a job board app might be protected by <b>&lt;tas&gt; candidate</b>
<li>a talent pool search app might be protected by <b>&lt;tas&gt; user</b>
<li>an app for sourcing candidates through recruitment agencies might be protected by <b>&lt;tas&gt; agency</b>
</ul> 
</p>

<p>TAS is SAML 2.0-based, so when someone authenticates at your SSO-protected app, your app receives a SAML authentication assertion.

<h2>Identity sources</h2>

<p>As a developer, your SSO-protected app receives incoming SAML assertions about principals (users) as you require them to log in.<p>

<p>Behind the scenes, and based on the tenant's choices, a single principal type may be mapped to multiple <b>identity sources</b>.</p>

<p>For example, the tenant acme may have configured things such that anyone can authenticate as a &lt;tas&gt; candidate if they have:
<ul>
<li>an account in the corporate IdP. Everyone like this gets marked as internal.
<li>an account in the legacy ATS support team. These people all get marked as internal, allowing them to debug internal-facing content issues.
<li>a candidate record in the legacy ATS. These people log in at a dialogue presented by TAS, but the ATS does the password checking. On successful login, the ATS passes through information in json, such as whether candidate is internal. That information gets injected as attributes in the eventual SAML assertion.
<li>a RealMe account. Since acme is an NZ public sector organization, RealMe is allowed. Marked as internal if they have an *@acme.com email.
<li>an email address. Marked as internal if they have an *@acme.com email.
<li>a LinkedIn account. Marked as internal if they have an *@acme.com email. Marked as alumni if they are in a the LinkedIn group 'Official ACME alumni group'
</ul>
</p>

<p>Your app normally would not care about these mappings, or about which identity source a user authenticated through - as far as it is concerned,
all authentications are just candidates, with an associated SAML assertion.</p>  

<b>TODO: Need to finally knock on the head the idea of &gt;1 principal types per app.</b>
</p>

<h3>OAuth APIs</h3>

<p>An app that is SSO-protected by a particular principal type can consume OAuth APIs
on any other installed app that is protected by the same principal type.</p>

<p>This allows a chain of user-aware API calls through any number of installed apps at the tenant.</p>

<p>For example if the dashboard app <b>compdashboard</b> is SSO-protected by &lt;tas&gt; user, and so is the app <b>payrollblast</b>,
then compdashboard can call OAuth APIs on payrollblast.<p>


<h3>Namespacing by developer</h3>

<p>As with APIs, to prevent name squatting principal types are in the namespace of the developer who defines them.</p>

<p>For example, the developer "tas" has defined these two principal types:
<ul>
<li>&lt;tas&gt; candidate</li>
<li>&lt;tas&gt; user</li>
</ul>
</p>

<p>As a developer, you can define your own principal types, e.g.:
<ul>
<li>&lt;supersoft&gt; candidate</li>
</ul>
</p>

<p>However doing your own thing means that your new principal type will not be usable by any existing app in TAS.
You would need to write new apps (or persuade others to) that used your principal type.</p>

<p>To get the most adoption for your app, it helps to reuse an existing principal type where possible. For example, if your app uses a common
principal type like &lt;tas&gt; candidate, then many tenants will be able to install your app and have it work straight away, since they
will have already defined the identity sources for &lt;tas&gt; candidate.</p>

<p>It follows too that your app will likely be able to call an API like GET &lt;tas&gt;/candidates to get a list of candidates. This makes your app
 more immediately valuable to customers.</p>



<h1>The session document</h1>


<p>TAS stores a json session document for every recently authenticated principal (user).</p>

<p>The TAS session document holds slowly changing information about the user such as:
<ul>
<li>their roles and entitlements (such as whether the user is a recruiter, and if so, for which department(s))
<li>their personal details (like first name and email)
<li>a set of common identifying information typically available from IdPs and social networks such as first name, last name, image, email, etc.
<li>anything specific to the user that apps wish to make available to themselves or to other apps, e.g. perhaps even OAuth tokens obtained from the authenticating social network
</ul>
</p>

<p>"Slowly changing" means that the TAS session is only updated at authentication time (as opposed to the more frequently changing data on the user's session in a specific app, e.g. a list of currently selected jobs).</p>

<p>Apps typically use the TAS session document to do things like user-based authentication checks, e.g. is this person allowed to see this web page? And if so, what menu items should they see?</p>

<p>As far as TAS is concerned, the session document is simply an opaque json document. TAS does not understand the structure of the document, it simply:
<ul>
<li>coordinates the document's assembly at user login time
<li>makes the document available to apps that are working on behalf of the user, i.e.:
<ul>
<li>SSO protected web sites
<li>OAuth API producers
</ul>
</ul>
<p>

<p>Apps can store anything they like, in any format that can be contained in json, inside the TAS session document. However the data should be small, i.e. in the order of kilobytes or less.</p>

<h2>How the session document is created</h2>

<p>TAS coordinates the creation of a user's session document whenever they log in to an SSO-protected app. The flow is shown below.</p>

<p> 
<div class='codeBlock'>

Below is a sample for the *candidate* principal type. Note we use home email and address for this type.

+------------------+
|external SAML IdP |
+------------------+
   |
   ...
   | attributes:
   | firstName = Barry
   | lastName = Gibb
   | email = bg@acme.com
   |
+-----------------------+
|TAS attribute mapping  |
+-----------------------+
   |
   | mapping rules:
   | firstName -> tas.name.givenName 
   | lastName -> tas.name.familyName
   | email -> tas.emails.home.email  
   |
   | updated attributes:
   | tas.name.givenName = Barry
   | tas.name.familyName = Gibb
   | tas.emails.home.email = bg@acme.com
   |   
+-----------------------+
|TAS auth filtering     |
+-----------------------+
   |
   | filtering rules:
   |
   |    "authFilters": [
   |        {
   |            "regexp": {
   |                "tas.emails.home.email": "*.aol.com"
   |            },
   |            "authPass": false
   |        },
   |        {
   |            "booleanTest": true,
   |            "inject": [
   |                {
   |                    "tas.bogus.value": "hello world"
   |                }
   |            ]
   |        },
   |        {
   |            "regexp": {
   |                "tas.emails.home.email": "*.acme.com"
   |            },
   |            "inject": [
   |                {
   |                    "tas.candidate.type": "internal"
   |                },
   |                {
   |                    "tas.candidate.type": "trusted"
   |                }
   |            ]
   |        }
   |    ]
   |
   | updated attributes:
   | tas.name.givenName = Barry
   | tas.name.familyName = Gibb
   | tas.emails.home.email = bg@acme.com
   | tas.bogus.value = hello world
   | tas.candidate.type = internal
   | tas.candidate.type = trusted
   |
+------------------------------+
|TAS session document creation |
+------------------------------+
</div>
</p>


<p>TAS composes the document from the data by merging data from:

<ol>
<li>specially named SAML attributes from the user's IdP (for example, a corporate Active
Directory system that holds against the user's record that they are a learner in the LMS,
or Facebook which knows that the user's first name is Fred)

<li>json merge documents passed back from "role-defining apps", which TAS calls
via POST /tenants/{tenant}/logins/{principalDev}/{principalType}/{entityID}/{nameID}
 (for example, a legacy ATS that holds against the user's record that they are allowed
 to search the candidate database).
</ol>
</p>

<p>In more detail, this merging happens as follows:

<ol>
<li>The user authenticates, and a SAML assertion flows back through the TAS SAML proxy, on its way
to the SSO-protected app (i.e., the Service Provider, or SP)

<li>
<p>Before passing the assertion to the SP, TAS examines its attributes and converts any that it
recognises to json. For example if a user logs with a SAML assertion containing:</p>

<div class='codeBlock'>
...
&lt;saml:Attribute NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified" Name="tas.roles.recruitment.recruiter.org"&gt;
	&lt;saml:AttributeValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="xs:string"&gt;sales_west&lt;/saml:AttributeValue&gt;
	&lt;saml:AttributeValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="xs:string"&gt;sales_east&lt;/saml:AttributeValue&gt;
&lt;/saml:Attribute&gt;
&lt;saml:Attribute NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified" Name="tas.roles.recruitment.recruiter.hasAdmin"&gt;
	&lt;saml:AttributeValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="xs:boolean"&gt;true&lt;/saml:AttributeValue&gt;
&lt;/saml:Attribute&gt;
</div>

<p>TAS converts this to this session document:</p>

<div class='codeBlock'>
{
    "recruitment": {
        "recruiter": {
            "org": [
                "sales_west",
                "sales_east"
            ],
            "hasAdmin": true
        }
    }
}
</div>

<p>The conversion is done using these rules [INCOMPLETE]:
<ul>
<li>leaf attributes of type other than boolean are treated as arrays
<li>attributes with multiple values and multiple attributes with the same name are treated the same (as arrays), and cannot be of type boolean
<li>passing false for attributes is not supported as ths conflicts with the merge patch semantics
</ul>
</p>

<li>
<p>Next, TAS gives every individual app tagged as loginListeners the chance to provide their own session data, by calling:</p>

<div class='codeBlock'>
POST /tenants/{tenant}/logins/{principalDev}/{principalType}/{entityID}/{nameID}
</div>

<p>In the request, TAS passes the starting session data (as extracted from the SAML assertion, see previous example).</p>

<p>In its response, the login listener can optionally pass include a json document to be merged into the session document.</p>

<p>For example, a learning management system (LMS) might pass back:</p>

<div class='codeBlock'>
{
    "learning": {
        "learner": true
    }
}
</div>

<p>After merging, the session data is now:</p>

<div class='codeBlock'>
{
    "learning": {
        "learner": true
    },
    "recruitment": {
        "recruiter": {
            "org": [
                "sales_west",
                "sales_east"
            ],
            "hasAdmin": true
        }
    }
}
</div>
</p>
</li>
</ol>

<h2>Merge details</h2>

<p>TAS merges session document data from login listeners with the IdP's session data using the patch merge semantics
defined in <a href='https://tools.ietf.org/html/rfc7386)'>rfc7386</a>.</p>

<p>TAS always merges the IdP's data into the login listeners data, rather than the other way around.
This ensures that the IdP's version of the user's roles/entitlements always takes precedence over any data held in apps.</p>

<p>If there are multiple login listeners, then each one sees only the IdP's session data in the request. I.e.: all login listeners are isolated from each
other for the purposes of building up their own session data.</p>

<p>If multiple login listeners pass back session data, TAS merges them in one at a time, in alphabetical order of app name. This means that
apps with later names could potentially undo or alter the session data from earlier apps.</p>

<p>TAS's use of the merge patch semantics of rfc7386 introduces some limitations. For example, the merge cannot operate on individual members
within an array, meaning that (for example) a manager could not be given authority over some departments via
SAML attributes and others via rows in an app's database. Instead,
the department list passed in SAML would completely replace any departments passed back by the login listener.</p>


<h2>Changes to the session document while user logged in</h2>

<p>In a case where the document contains details of the user's roles, those roles might change while the user is logged in (e.g. when an administrator
changes the user's permissions thourgh some admin screen, or directly on the IdP).</p>

<p>However since user's session document is fixed at the time when they log in to an SSO-protected app, those role changes would not be seen until the user reauthenticates.</p>

<p>Depending on the expiry details in the SAML authentication assertion, this might be every few minutes, or hours.</p>


<h2>Accessing the session document from within an app</h2>

<p>To obtain the session document, apps use the entityID and nameID representing the logged in user to call:</p>

<div class='codeBlock'>
GET /tenants/{tenant}/logins/{principalDeveloper}/{principalType}/{entityID}/{nameID}
</div>

<p>An app with an SSO-protected web page can parse the entityID and nameID from the incoming SAML assertion (using the TAS-supplied library).<p>

<p>An app which is an API producer can extract the entityID and nameID from the incoming OAuth token.</p>

<h2>Session document and auto-provisioning</h2>

<p>Auto-provisioning refers to creating users "on the fly", i.e. at the time when they first log in.</p>

<p>To decide whether, and how, to auto-provisioning a new logging in user, an app may look at information
in the user's session document, like their email, or their permissions.</p>

<p>That session document was built in the first place by TAS intercepting the user's login, and using that opportunity
to call each loginListener in turn, merging their responses into the master session document.</p>

<p>Although apps normally auto-provision users at the point where they first login to the app, it is also theoretically possible for
loginListening apps to do auto-provisioning, i.e. when the user logs in at some <b>other</b> app. However because loginListeners only see the
base session document, i.e. the one built from IdP-supplied data alone, and not the session data from all of the other loginListeners,
auto-provisioning in this way may not be desirable.</p>

<h2>Apps that are both auto-provisioning and loginListeners</h2>

<p>In a situation where a loginListener app is asked to produce session data for a user that does not exist in the app, but would due
to auto-provisioning were they to log in to the app, then the app should normally provide session data just as if the user had been
auto-provisioned.</p>

<p>This sort of situation would arise for example with a legacy ATS app designed to auto-provision new users and grant them access to a
separate candidate search app. In this case, if the user logs in to the search app first, having never visisted the legacy ATS app, then
the legacy ATS app (acting as a loginListener) should attach session data (possibly including the right to access the search app)
as if the user had instead logged into the ATS first and therefore been auto-provisioned and gained the default permissions.</p>
 

<h1>Storefront apps</h1>

<p>Storefront apps are specially privileged apps that perform actions on TAS itself, like installing apps, adding identity sources, etc.<p>

<p>Storefront apps need to be tagged as "storeFront" by TAS support. Please contact TAS if you want to build a storefront app.</p>

<p>In theory multiple storefront apps can coexist within the same tenant.<p>


<h2>Patching a store</h2>

<p>All changes to a store's configuration - i.e. installs, edits or uninstalls of the apps and identity sources making up the store - 
are made via patch documents (documents that conform to the HTTP PATCH semantics described in https://tools.ietf.org/html/rfc6902).</p>

<p>As per the RFC, all changes in the patch set are made with a single atomic transaction.</p>

<h3>Additional patch semantics</h3>

<p>TAS supports an additional id-based path style inspired by SCIM (https://tools.ietf.org/html/draft-ietf-scim-api-12), except that EMCA script is used, e.g.:</p>

<p>This path points to the installed app "tas-legacyats".</p>

<div class='codeBlock'>
"path": "installs[app=='tas-legacyats']"
</div>

<h3>Patch examples</h3>

<p>This example updates the baseUri on the "main" server of the installed app "tas-legacyats".</p>

<div class='codeBlock'>
PATCH /{tenant}
[
{ "op": "replace", "path": "installs[app=='tas-legacyats'].servers[name=='main'].baseUri", "value": "https://newlocation.com/api"
]
</div>


<p>This example installs the app "zongo" from the developer "zwarg", after first checking that the store is still at incarnation 23.</p>

<div class='codeBlock'>
PATCH /{tenant}
[
  { "op": "test", "path": "status.incarnation", "value": 23 },
  { "op": "add", "path": "status.installs.-", "value": {"app": "zwarg-zongo"} }
]
</div>

<p>This example installs an app with a server override (i.e., a non-multi tenanted app such as a legacy ATS).</p>

<div class='codeBlock'>
PATCH /{tenant}
[
  { "op": "test", "path": "/incarnation", "value": 23 },
  { "op": "add", "path": "/installs/-", "value": {"app": "tas-legacyats", "servers": [{"name": "ats0", "basicAuthCredentials": {"user": "fred", "password": "secret1"}}]} }
]
</div>

<p>This example changes the password for the previously installed app:</p>

<div class='codeBlock'>
PATCH /{tenant}
[
  { "op": "test", "path": "/incarnation", "value": 23 },
  { "op": "add", "path": "/installs/6/servers/0/basicAuthCredentials/password", "value": "secret2" }
]
</div>

<p>This example sets up a new tenant:
<ol>
<li>creates the store for a new tenant "acme"
<li>installs the storefront app
<li>installs a single identity source for the bootstrap IdP
<li>hardcodes all people in the bootstrap IdP as "hrStoreAppAdmin" and "hrStoreIdentityAdmin", so that they can manage the store.
</ol>
</p>


<div class='codeBlock'>
PATCH /{tenant}
[
{
    "op": "add",
    "path": "/",
    "value": {
        "details": {
            "organizationName": "ACME Corporation",
            "shortCode": "acme",
            "description": "A test site while we see if this stuff works",
            "country": "US",
            "industry": "Manufacturing"
        },
        "installs": [
            {
                "app": "tas-storefront"
            }
        ],
        "identitySourceSets": [
            {
                "principalDeveloper": "tas",
                "principalType": "user",
                "identitySources": [
                    {
                        "kind": "bootstrapIdentitySource",
                        "description": "The store owner automatically gets access to manage the store",
                        "attributeOverrides": [
                            {
                                "filter": "*",
                                "ifMatched": [
                                    {
                                        "name": "tas-user-roles",
                                        "values": [
                                            "hrStoreIdentityAdmin",
                                            "hrStoreAppsAdmin",
                                            "hrStoreViewer"
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        ]
    }
}
]
</div>

<h2>Applying a patch</h2>

<p>To apply a patch document to a tenant, your storefront app makes a series of API calls, as shown in the example below:<p>

<ol>
<li>The user (an HR admin person) is at the app details page within your storefront web site.</li>
<li>They click install on the app, submitting a web form</li>
<li>Your app's server code composes a patch document based on the user's input.</li>
<li>Your app's server code POSTS to /{tenant}/patchSets, with:
<ol>
<li>the patch document
<li>the continue page, i.e. where the storefront would like the user to end up on completion
</ol>
..and checks for errors.</li>
<li>The response from TAS contains a signed JWT, which embeds the original patch document and the continue page.</li>
<li>Your server code inserts the JWT into the onClick handler of a new "confirm" button on the app details page.</li>
<li>The user is now back at the app details page. They click confirm.</li>
<li>The browser opens a progress dialog.</li>
<li>The browser submits the JWT, including the original patch document, via an ajax call to PATCH /{tenant}.</li>
<li>The call returns immediately with a launch key and the first few items of the patch log.</li>  
<li>The browser writes the patch log to the progress dialog.</li>
<li>The browser immediately makes another ajax call to GET /{tenant}/patchLaunches/{launchKey}
<li>This is a long polling method, which returns as soon as any new patch log items are available.</li>
<li>The browser loops, making repeated ajax calls to GET /{tenant}/patchLaunches/{launchKey} and adding new log messages to the progress dialog, until the operation is complete.</li>
<li>The final response from GET /{tenant}/patchLaunches/{launchKey} includes the URI of the continue page.
<li>The browser displays a "patch complete" message to the user, and a "Continue" button.
<li>On pressing Continue, the user is redirected to the continue page.
<li>We're done.  
</ol> 

<p>The complexity of the interactions, and the use of JWTs, is necessary:
<ul>
<li>to allow the progress dialog to continue throughout, even when
<ul>
<li>the storefront app itself is stopped and started like all other apps as the patch set is applied</li>
<li>the storefront app is swapped out for another one as part of the changes</li>
</ul>
<li>to reflect the insecure nature of making ajax calls from the browser
</ul>

<h2>How TAS applies patch sets</h2>

<p>To apply a patch set, TAS does the following:
<ol>
<li>requests each already installed app to shut down</li>
<li>applies the set</li>
<li>resets all volatile credentials for the tenant:
<ul>
<li>The tenant's own private/public key pair (as obtained via GET /{tenant})
<li>All HMAC signing keys (as held on routes)
</ul>
<li>Increments the tenant's incarnation (thus invalidating all existing OAuth tokens)
<li>detects whether the delta set includes uninstalling the app that created tha launcher, and if
so calls GET /m/storeFrontMainPage to get a new continue page. Note this prevents an about-to-be-uninstalled storefront
from specifying any continue page, not just a page on itself.
<li>sends startup requests to each installed app</li>
</ol>
</p>

<p>In parallel to the above, TAS causes any outstanding long polling calls to GET /{tenant}/patchSetLaunches to return
each time there is a new available event. A maximum of 100 events are returned per call.</p>


<h2>Bootstrap patch set</h2>

<p>As well as patching existing tenants, storefront apps can also create new tenants, for example:

<ul>
<li>when a new tenant creates their store
<li>when an existing tenant copies their store (e.g. to create a testing/sandbox site)
</ul>
</p>
 
<p>POST /tenantBootstraps/{tenant}</p>

<p>Once this launch is complete, the storefront app can take over the UI. TAS will call GET /storeFrontMain.</p>



<h1>Portfolio apps</h1>

<p>TAS apps operate, and call each other via tenant APIs, solely within the context of a tenant.
For example, it is not possible for (and TAS will not issue or validate tokens for) a consuming app
running on behalf of one tenant to make a API call to a producing app running on behalf of another tenant.</p>

<p>However some apps may also want to present a public face, not associated with any specific tenant.</p>

<p>For example, a job board (say, for plumbers) may present a public web site (www.plumberjobs.com) where candidates can register and profile themselves. In this situation, a candidate should be able:
<ol>
<li>authenticate (e.g. via Google) and profile themselves at www.plumberjobs.com
<li>at a later date, authenticate via the same Google account and apply for a plumbing job at a tenant, and access the information from their previously set up profile.
</ol>

<p>This can be achieved via a setup like the following:

<ol>
<li>www.plumberjobs.com is implemented as an (unlisted) app intended to be used only once, to power the www.plumberjobs.com website
<li>The app is linked to the &lt;tas&gt; candidate principal type, and therefore can therefore protect its own pages via the TAS SSO system
<li>The developer creates a tenant
<li>The tenant installs the app
<li>The tenant links the &lt;tas&gt; candidate principal type to common/global identity sources (e.g. Google, Facebook, LinkedIn)
<li>The site is now live, and can start capturing plumbers, who protect their details using their preferred login mechanism (e.g. Facebook)
<li>The developer now creates a second (listed) app, "plumbersbackend"
<li>That app implements the well-known non-SoT API /m/candidates/{}
<li>[complete..]      
</ol>


<script>
$(document).ready(function() {

	renderSequenceDiagrams();
	renderClientIncludes();
	renderTOC();
});
</script>


</body>
</html>