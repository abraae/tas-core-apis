<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<!-- always required -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>

<!-- needed for sequence diagrams -->
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/raphael-min.js'></script>
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/underscore-min.js'></script>
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/sequence-diagram-min.js'></script>
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/sequence-diagram-wrapper.js'></script>

<!-- needed for includes -->
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/clientInclude.js'></script>

<!-- needed for table of contents -->
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/tocify.js'></script>

<link rel="stylesheet" href="//normalize-css.googlecode.com/svn/trunk/normalize.css" />

<!-- always required -->
<link rel='stylesheet' href='http://talentappstore.github.io/tas-des-static/css/des.css' type='text/css' media='all' />

<title>Talent App Store app developer guide</title>
</head>
<body>


<h1>Talent App Store app developer guide</h1>

<p>See us on <a href='https://github.com/talentappstore/tas-core-apis'>Github</a>.
</p>

<p>We love feedback. Please get in touch at abraae@aotal.com.</p> 


<div id="toc"></div>

<h1>About Talent App Store</h1>

<h2>Why microservices?</h2>
<p>Traditionally, an organization assembling an HR technology stack would
go to a single vendor and buy a "hire to retire" software suite spanning recruitment,
onboarding, compensation, performance management, payroll and everything in between.
</p>

<p>Microservices turn this model on its head. Instead of buying a single suite of software,
an organization can assemble tens or hundreds of pre-integrated, highly focused apps into
a best of breed HR technology stack. Software buying becomes agile - demoing and trialing a new
HR app and moving it into production takes minutes, not months.
</p>

<p>Talent App Store is a API and identity platform for HR SaaS microservices.</p>

<p>Tenants (i.e., customers) can click to install small, pre-integrated
HR web applications that present to the user as a "single pane of glass".</p>


<h2>Developer benefits</h2>

<p>To you, as the developer of a talent management app, Talent App Store brings you these benefits:

<dl>

<dt>A sales channel</dt>
<dd>Hundreds of customers are able to use TAS, making thousands of API
endpoints available. If you have a product that solves some talent management problem better
than anyone else, you now have access to a ready market of people who can click to provision your
product in seconds.
</dd>

<dt>Rock solid security</dt>
<dd>One of the hardest aspects of selling HR software to enterprises is addressing the
IT team's security demands. In TAS, your app runs within an industry standard
security and identity framework, using technologies like SSO via SAML, OAuth and others.
TAS handles all of the heavy lifting of security for you, frees you from the
risky business of managing user authentication, and allows you to make binding guarantees
to customers about the safety of their data within your app. 
</dd>

<dt>A demo packaging service</dt>
<dd>With TAS, you can define shopping lists of microservices
that support your app, such as databases of demo jobs, org structures, and wrap these around
your app. Customers can click to trial your app as a part of a complete, functioning technology stack.
</dd>

</dl>


<h2>Architecture</h2>

<p>The TAS core is a database of apps, APIs, and tenants and their currently installed apps.</p>

<p>Over this database is layered a secure, high speed, globally distributed API discovery engine
and identity proxy, hosted on Amazon Web Services.</p>

<p>The core acts as an Outh authorization server, and allows secure tenant API calls
between the the tenant's installed apps:</p>

<p>
<b>Core vs. tenant APIs in Talent App Store</b>
<div class='seqDiag' id="apitypes">
participant TAS
participant ATS app
participant Career site app
participant Social sharing app
TAS->ATS app: outwards core API, e.g. stop tenant, start tenant,\nadd tenant, delete tenant
TAS->Career site app:
TAS->Social sharing app:
ATS app->TAS: inwards core API, e.g. locate API endpoint,\nobtain access token, signal shutdown complete
Career site app->TAS:
Social sharing app->TAS:
Career site app->ATS app:tenant API call, e.g. GET /openJobs
Social sharing app->ATS app:tenant API call, e.g. GET /openJobs/{id}
</div>

<p>The discovery engine provides APIs for your app to dynamically
locate API endpoints on other apps, based on the tenant's latest installation choices.
For example, your app wants to call GET /openings. The discovery engine points your app at
whichever app (based on the customer's installation choices) is currently producing that endpoint. If the customer swaps
out their ATS and replaces it with another, your app continues calling GET /openings without interruption.
</p>

<p>In a typical HR integrated talent management suite, API calls are in to, or out of, the mothership.
In TAS, there is no mothership. All apps are equal. Any app can produce any API, and any app can consume any API on any other app.
This decentralization is deliberate, with the purpose of giving customers choice, preventing lock-in and
making them masters of their own destiny by allowing them to swap out any app and replace it with another one.</p>

<p>The core also acts as an identity proxy and Single Sign On (SSO) system based on industry
standard SAML, and available to all of the tenant's installed apps. If your app presents a web user interface,
then TAS handles logins to your app in a secure, customer-controlled way. SAML support and SSO is increasingly
understood by customers to be a key part of any integrated talent management platform.
</p>

<p>The core provides the runtime glue for all of a tenant's apps to securely make API calls
to each together, and for users to be able to SSO in, seamlessly navigate between apps, and
create OAuth access tokens.
</p>

<p>When a tenant installs your app, the core orchestrates provisioning API calls in to your app.
Your app responds by inserting a row into your customer table, spinning up an ec2 instance or docker container or whatever.
</p>

<p>A storefront web app provides screens for tenants to:
<ul>
<li>register
<li>install and uninstall apps
<li>configure their identity providers
</ul>
</p>

<p>The developer web site provides screens for developers to:
<ul>
<li>register
<li>define APIs
<li>define apps
</ul>


<h2>What its not</h2>

<p>TAS is not:
<ul>
<li>TAS is not an IaaS or a hosting platform. You host your apps yourself
on your own infrastructure.

<li>TAS is not a programming language or a framework. You can write your apps
in your language of choice, using whatever user interface framework you favour
and storing your data in your chosen database. TAS helps you to communicate
with other apps, and with TAS itself, via http-based REST APIs.

<li>TAS is not an ESB (Enterprise Service Bus). API traffic flows directly
between apps, and does not pass through any TAS server. TAS is
not a bottleneck or a point of failure.
</ul>


<h1>Concepts and parties</h1>

<h2>Developers</h2>

<p>Developers are organizations who:
<ul>
<li>create apps
<li>define APIs
</ul>

<p>Developers register at <a href='https://developer.talentappstore.com'>developer.talentappstore.com</a>.
</p>


<h2>Tenants</h2>

<p>Tenants are organizations who use Talent App Store to build up their HR technology stack.</p>

<p>Tenants register at <a href='https://www.talentappstore.com'>www.talentappstore.com</a>.
</p>

<p>Once registered, a tenant can:
<ul>
<li>install apps into their tenant
<li>configure idps (identity providers) to define who can access their installed apps
</ul>
</p>


<h2>Apps</h2>

<p>Apps (microservices) are multi-tenanted web apps that work together with
other apps to make up the tenant's overall HR technology stack.
</p>

<p>Apps make REST API calls to each other on behalf of their tenant.
</p>


<h2>Principal types</h2>

<p>A principal type is a class of (typically) person who can:
<ul>
<li>log into a TAS SSO-protected app
<li>have API calls made on their behalf
</ul>
</p>

<p>For example:
<ul>
<li>a job board app might be SSO protected by <b>&lt;tas&gt; candidate</b>
<li>a talent pool search app might be SSO protected by <b>&lt;tas&gt; user</b>
<li>an app for sourcing candidates through recruitment agencies might be SSO protected by <b>&lt;tas&gt; agency</b>
<li>an app for applying for jobs might make an API call like GET /applications on behalf of a specific <b>&lt;tas&gt; candidate</b>  
</ul> 
</p>

<p>The principal type acts as a boundry between the app and the tenant. Apps deal in principal types, tenants
map those principal types to their own, specific idps.
 
<p>For example, the tenant acme might have set mapped the principal type of candidate to these idps:
<ul>
<li>Corporate idp, e.g. Active Directory. Everyone like this gets the internal role.
<li>Backdoor idp - these people log in at a dialogue presented by TAS,
but the TAS delegates the password checking to some database of identities (e.g. the users table of an ATS)  
<li>RealMe. Since acme is an NZ public sector organization, RealMe is allowed. Marked as internal if they have an *@acme.com email.
<li>LinkedIn. Marked as internal if they have an *@acme.com email. Marked as alumni if they are in the LinkedIn group 'Official ACME alumni group'
</ul>
</p>


<h2>APIs</h2>

<p>The REST APIs that apps consume and produce on each other are called tenant APIs.</p>

<p>Each tenant API belongs to a developer, who documents the API and its behaviour:
<ul>
<li>URI template, e.g. /openings
<li>supported http methods, e.g. POST, GET, DELETE
</ul>
</p>

<p>Any app that produces an API must support all the http methods listed.</p>

<h3>Registering APIs</h3>

<p>As well as writing apps that consume or produce existing APIs, app developers can also register new APIs themselves. It is
a contractual requirement that any APIs you register with TAS are open sourced, so that other
developers can use your API in their apps.</p>

<h2>Apps</h2>

<p>Apps are multi-tenanted web apps that are built and hosted by their developers. TAS is not a hosting platform.
</p>

<p>You can build an app using any web technologies and language. Since apps communicate through REST
API calls, most modern web technology stacks are suitable for building apps.
</p>

<h2>APIs</h2>

<p>TAS allows apps to securely make REST API calls to each other, by acting as an OAuth authorization server.
</p>

<p>Every app defines which APIs it consumes, and which it produces.
</p>

<p>For example, your job board app might declare that it consumes GET /openings (so it can regularly check
whether the tenant has new jobs).
</p>

<p>Your ATS app might declare that it produces /openings (it has the big picture of the tenant's open jobs).</p>


<h3>SoT</h3>

<p>When your app produces an API (like /openings) it can do so as "source of truth" (SoT).
</p>

<p>SoT APIs are easier for other apps to consume. Any app that wants a list of all open jobs
via GET /openings is directed to the source of truth app producing the API. Because there is only
one source of truth, the consumer doesn't need to think about how to merge multiple sets of job
openings.
</p>

<p>The tenant can only install one app as source of truth at any one time.
</p>

<p>There are many natural sources of truth in HR apps, e.g. for job openings, candidates, job applications, job board postings,
onboardings events, employee referrals, etc.
</p>
  

<h3>Non-SoT</h3>

<p>Apps can also produce APIs as non-SoT.
</p>

<p>Any number of apps can be installed at once that produce an API as non-SoT.
</p>

<p>There are many endpoints that are non-SoT in HR apps, e.g.:
<ul>
<li>A tenant installs multiple job board apps. Each one produces /categories as non-SoT. The job board posting hub app can now
pull down the category setup for each of the job boards and maintain a local mapping to the tenant's source of truth for /categories.
<li>multiple apps that cared about new job openings could produce /openings/{id}/deltaPings as non-SoT.  
</ul>
</p>

<p>Consuming non-SoT APIs is harder work for the app developer and means dealing with fringe cases and network failures.
For example, new job opening 10223 being created, what happens if the API call to the first producer of POST /openings/10223/deltaPings succeeds
but to the next producer fails?
</p>

<p>An app can only produce an API as either SoT or non-SoT - not both.</p>


<h2>Making API calls</h2>

<p>TAS helps your app make API calls by:
<ul>
<li>acting as a directory, for example by and providing your job board app with with the location of whichever installed app
is currently source of truth for /openings
<li>acting as an OAuth authorization server, and providing an access token.
</ul>
</p>

<p>Although TAS helps apps to find and make calls to each other, it does not take part in any way in the actual REST API call - that
always takes place directly between the consuming app and the producing app. This avoids creating any single
bottleneck or point of failure into the ecosystem.
</p>



<h1>Building apps</h1>

<h2>Registering your app</h2>

<p>Do so at https://developers.talentappstore.com.
</p>

<h2>Provisioning</h2>

<p>When a tenant uses the storefront to install your app, your app receives an incoming API call that
it has a new tenant and passes their name, org details, etc.. Internally your app might insert a row into its
customers table, create a working directory on a file server, etc., or otherwise
lay out any resources needed for the new tenant.
</p>

<h2>SSO</h2>

<p>If your app has a web interface, TAS makes it easy to protect it using SAML. SAML is an industry standard
for SSO adopted by SaaS vendors like Dropbox, Slack, Salesforce and many others.
</p>

<p>You don't need to add SAML to your app, and you can choose to continue using your existing login system.
</p>

<p>However as well as being very desirable to customers (particularly their IT security teams), it's straightforward to add SAML
to your app. Most web development environments provide SAML plugins or filters.
</p>

<p>To add SAML to your app:
<ul>
<li>find a SAML library or plugin for your environment (e.g. Spring Security SAML http://projects.spring.io/spring-security-saml/
<li>configure the SAML library to protect some or all of your web pages
<li>when new tenants install your app, create an SP (service provider) in your app
</ul>
</p>

<p>Even though TAS lets tenants mix and match multiple identity providers (like Google, Facebook, LinkedIn and the tenant's own in-house
identity provider), your app is shielded and just deals with a single identity provider proxy.
</p>

<h2>Auto-provisioning of new users</h2>

<p>TAS allows you to protect your app so that only people trusted by the SSO can log into your app.
</p>

<p>Some apps however need not just a login, but also an actual row in their own users (or candidates or whatever) table.
</p>

<p>If your app is like this, you should consider adding user just-in-time provisioning.</p>  


<h2>Consuming APIs</h2>

<p>This section describes how your app consumes tenant APIs, i.e. makes API calls to other installed apps.</p>

<h3>Fetch the route(s) for the API</h3>

<p>The first step in calling an API is to fetch the route(s) for it.</p>

<p>A route is a usage of a specific tenant API, on a specific producing app installed at the producing tenant,
by a specific consuming app installed at the consuming tenant.</p>

<p>For example:
<ul>
<li>the app "ats"
<li>by the developer "smartyhr"
<li>and installed by the tenant "acme"
<li>wants to make a GET call to every app that produces
<li>the API "/categories"
<li>as defined by the developer "tas"
</ul>
</p>

<p>To fetch the routes (plural since this is non-SoT), the ats app calls:

<div class='codeBlock'>
GET /routes/acme/smartyhr/ats/tas/%2Fcategories/false

Response:
<div class='clientInclude' data-href='../examples/routes-simple.json'></div>
</div>
</p>

<p>From the response, the smartyhr-ats app can see that acme has installed two apps that
produce /categories. The response also includes the physical endpoint details.
</p>

<p>The smartyhr-ats app wants to make an API call to the first producer, the greenjobs-gjcore app.
</p>


<h3>Obtain an OAuth access token</h3>

<p>In TAS, tenant API calls are OAuth protected, which means the consumer of the API needs to obtain 
an OAuth token and then pass it in the Authorization header of the API call.
</p>

<p>TAS supports several different ways to obtain an OAuth access token.
</p>

<p>For more background on OAuth and tokens, see the <a href='http://tools.ietf.org/html/rfc6749'>OAuth 2 spec</a>
and also Google's <a href='https://developers.google.com/accounts/docs/OAuth2WebServer'>OAuth documentation</a> for additional context.
</p>

<img src='images/legend.jpg' style="width: 40%; height: 40%"/>​
<br />


<h4>Anonymous token</h4>

<p>Anonymous OAuth tokens are used to make API calls that are not specific to any particular principal (user).
</p>

<img src='images/anonymous.jpg' style="width: 40%; height: 40%"/>​
<br />

<p>Any app that consumes an API can use the <a href='https://tools.ietf.org/html/rfc6749#section-4.4'>OAuth client credentials grant type</a> to
create an anonymous OAuth token.
</p>

<p>In this example:
<ul>
<li>the second route for the /categories API leads to the app "gjcore", installed at the tenant "greenjobsite"
<li>the ats app's business logic is such that it wants to call the /categories API using an anonymous OAuth token.
</ul>
</p>

<p>In TAS, OAuth tokens are scoped by the combination of the consuming app install and the producing app install.
Therefore the app starts by composing a string specifying the "from" and "to" installed apps:

<div class='codeBlock'>
/acme/smartyhr/ats/greenjobsite/greenjobs/gjcore
</div>
</p>

<p>The ats app can now fetch the an anonymous OAuth token via a call to the token endpoint:

<div class='codeBlock'>
POST /oauth2/v1/token HTTP/1.1
Host: core.talentappstore.com
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
scope=/acme/smartyhr/ats/greenjobsite/greenjobs/gjcore
</div>
</p>

<p>TAS issues a new access token and passes it back. Anonymous access tokens created by TAS
always expire one hour after they are issued.

<div class='codeBlock'>
Response:
{
  "access_token":"1/fFAGRNJru1FTz70BzhT3Zg",
  "expires_in":3600,
  "token_type":"Bearer",
}
</div>
</p>

<p><b>Note:</b> the client credentials described in the OAuth 2 spec do not need to be passed in
the call to GET /token, as all TAS core API calls are secured via HMAC which securely
identifies the client (i.e. the consuming app).
</p>

<p>With an anonymous token, the API producer can't apply any principal-specific logic or security
(e.g. only allowing users in the finance department to view account details, or logging
on the server who the user was who created a job, etc.).
</p>

<h4>On behalf token</h4>

<p>Another type of OAuth token is an on behalf (principal-aware) token. While its easy for apps to create anonymous
access tokens, some APIs behave differently or will only work with a personal token, e.g. an app that serves
information about a specific user.
</p>

<img src='images/onbehalf.jpg' style="width: 40%; height: 40%"/>​
<br />

<p>Any app that consumes an API and is protected via TAS SSO can use the
<a href='https://tools.ietf.org/html/draft-ietf-oauth-saml2-bearer-23#section-2.1'>OAuth SAML bearer assertion</a>
grant type, along with the original SAML assertion, to create an on behalf OAuth token.
</p>

<p>In this example, the ats app could create an on behalf OAuth token like this:

<div class='codeBlock'>
POST /oauth2/v1/token HTTP/1.1
Host: core.talentappstore.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-bearer
scope=/acme/smartyhr/ats/greenjobsite/greenjobs/gjcore
assertion=kjh9786gJHGutvfUT765Kkjghf70978klhjhgIUYGkpoiygEciYnjOi...
</div>
</p>

<p>TAS creates a new access token which has the principal's entity ID and name ID embedded
within it, and and passes it back.
</p>

<p>The tokens expiry time will be either in one hour, or at the time dictated by the original SAML
assertion's "on or before" field (TODO: be specific), whichever is sooner.

<div class='codeBlock'>
Response:
{
  "access_token":"1/Gthf5RhgIUvfKUY684578hT3Zg",
  "expires_in":1533,
  "token_type":"Bearer"
}
</div>
</p>

<h4>Refresh token (offline use)</h4>

<p>Some apps need to continue making API calls on behalf of a user, even when the user is no longer logged in.
</p>

<img src='images/onbehalfrefresh.jpg' style="width: 40%; height: 40%"/>​
<br />

<p>Any app that consumes an API and is protected via TAS SSO and is marked as "offline capable" (TODO:
exact name) can use the <a href='https://tools.ietf.org/html/draft-ietf-oauth-saml2-bearer-23#section-2.1'>OAuth SAML bearer assertion</a>
grant type to create a principal-aware OAuth token and an accompanying refresh token.
</p>

<p>The access token can be used immediately, and when it expires, the refresh token can be used to generate new
access tokens even when the user is no longer logged in.
</p>

<p>The token request is the same as ordinary principal-aware request, except that the app adds
the keyword "offline" to the scope parameter.

<div class='codeBlock'>
POST /oauth2/v1/token HTTP/1.1
Host: core.talentappstore.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-bearer
scope=/acme/smartyhr/ats/greenjobsite/greenjobs/gjcore%20offline
assertion=kjh9786gJHGutvfUT765Kkjghf70978klhjhgIUYGkpoiygEciYnjOi...
</div>
</p>

<p>The response contains a refresh token alongside the usual access token. Your app should
store the refresh token in its own long-term storage.

<div class='codeBlock'>
Response:
{
  "access_token":"iuhy76YT785L0GDF23JH7kjhd",
  "expires_in":3600,
  "token_type":"Bearer",
  "refresh_token":"j089777bhkltyHTRFG78969KJH968d"
}
</div>
</p>

<p><b>Note:</b> internally, TAS stores a copy of refresh tokens that it has issued, so it can validate
requests for new access tokens. These refresh tokens are stored keyed by:
<ul>
<li>user identifier (/E/N)
<li>the SSO-protected app the user logged into (the API consuming app in this case)
<li>consuming app install
<li>producing app install
</ul>
</p>

<p>You should save refresh tokens in long-term storage and continue to use them as long as they
remain valid. If your application requests another refresh token for the same combination of
user, app and app route as described above, a new refresh token will be issued and any previous
refresh token will be revoked.
</p>

<p><b>Note:</b> you only need to use refresh tokens if the offline activity is on behalf of a specific user. Otherwise
your app can simply request a new anonymous OAuth token as soon as the existing one expires.
</p>

<h4>Access token via a refresh token</h4>

<p>Some apps need to continue making API calls on behalf of a user, even when the user is no longer logged in.
</p>

<img src='images/refresh.jpg' style="width: 40%; height: 40%"/>​
<br />

<p>Any app that has obtained both an access token and a refresh token (via a prior call to the
token endpoint with scope of "offline") can <a href='https://tools.ietf.org/html/rfc6749#section-6'>use the refresh token</a>
to create a new access token once the original access token expires.
</p>

<p>In this way, an app can continuously generate access tokens and act on behalf of a principal, even when that
user may be no longer logged in.
</p>

<p>The token request is as follows:

<div class='codeBlock'>
POST /oauth2/v1/token HTTP/1.1
Host: core.talentappstore.com
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token
refresh_token=j089777bhkltyHTRFG78969KJH968d

Response:
{
  "access_token":"iuhy76jhbitypLIUhLKkdlkjdnd23JH7kjhd",
  "expires_in":3600,
  "token_type":"Bearer"
}
</div>
</p>

<p>Access tokens created via a refresh token always have an expiry of one hour.</p>

<h4>Access token from incoming access token</h4>

<p>Some apps that are API producers in turn consume other APIs, i.e. they are an intermediate link in a chain of API calls.
</p>

<img src='images/inherited.jpg' style="width: 40%; height: 40%"/>​
<br />

<p>Any app that is an API producer can use the grant type "urn:talentappstore.com:oauth2:tas-inherited"
with the parameters parent_token and scope to generate a new access token.
</p>

<p>As when generating an anonymous token, the consuming app starts by composing a string specifying the "from"
and "to" installed apps, e.g. in this example where the gjcore app consumes an API on the gjrefcodes app:

<div class='codeBlock'>
/greenjobsite/greenjobs/gjcore/greenjobsite/greenjobs/gjrefcodes/
</div>
<p>

<p>The gjcore app can now request an OAuth token via a call to the token endpoint:

<div class='codeBlock'>
POST /oauth2/v1/token HTTP/1.1
Host: core.talentappstore.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn%3Atalentappstore.com%3Aoauth2%3Atas-inherited
scope=/acme/smartyhr/ats/greenjobsite/greenjobs/gjcore
parent_token=iuhy76jhbitypLIUhLKkdlkjdnd23JH7kjhd
</div>
</p>

<p>TAS issues a new access token and passes it back.
</p>

<p>The new access token inherits details of the principal (if any) and the expiry time 
from the parent access token. This means all access tokens created as part of a nested set
of API calls will expire simultaneously.

<div class='codeBlock'>
Response:
{
  "access_token":"1/fFAGRNJru1FTz70BzhT3Zg",
  "expires_in":2012,
  "token_type":"Bearer",
}
</div>
</p>

<h3>Calling the API</h3>

<p>Once an access token is obtained, the app can now make the API call, by embedding the OAuth token
in the http Authorization field, for example:

<div class='codeBlock'>
POST /v1/categories HTTP/1.1
Host: api.greenjobs.co.nz
Content-Type: application/json
Authorization: Bearer 1/fFAGRNJru1FTz70BzhT3Zg
</div>
</p>


<h3>Caching of tokens by consumers</h3>

<p>Consuming apps should cache access tokens rather than requesting new tokens for every API call they make.</p>


<h3>Revoking a refresh token</h3>

<p>To programmatically revoke a refresh token, your app makes a request to the revoke endpoint that
includes the refresh token as a parameter:

<div class='codeBlock'>
https://core.talentappstore.com/oauth2/v1/revoke?token={token}
</div>
</p>

<p>TODO: add to corein.raml</p>

<p>Revoking a refresh token does not revoke any associated access tokens (TAS does not store access tokens).
</p>

<h3>Incrementing the security generation</h3>

<p>In the event of a security breach, a tenant may want to perform a bulk revocation of SAML
assertions, TAS sessions and refresh and access tokens.
</p>

<p>This has the effect of forcing all principals at the tenant to log in again. Apps that perform
background or batch operations will need to obtain new refresh tokens.
</p>

<p>TODO: complete</p>


<h2>Producing APIs</h2>

<h3>Producing an API on a local endpoint</h3>

<p>This is a typical REST API endpoint, e.g. a Spring MVC controller.

<h3>Producing an API on a remote endpoint</h3>

<p>Apps can produce APIs (SoT or non-SoT) by "remote mounting" a specified tenant's SoT production of the same API.</p>

<p>For example:
<ol>
<li>tenant acme has installed a number of job board apps
<li>the tenant wants each job board app to produce (non-SoT) the /categories API
<li>then acme's other apps can query each job board's unique category setup, build mappings, etc.
<li>the job board "green jobs" provides such a job board app
<li>that app produces (non-SoT) /categories
<li>however it does so by remote mounting the same API at the central green jobs tenant
<li>inside the green jobs tenant, the app "corestuff" produces (SoT) the /categories API
<li>therefore corestuff finishes up producing the API when consumed by some other app at the acme tenant 
</ol>
</p>

<p>TAS detects and disallows loops.</p> 

<h3>Verifying incoming access tokens</h3>

<p>The first step in verifying a call to a tenant API is to verify that the incoming OAuth token (found in
the Authorization header) is valid and appropriate.
</p>

<p>OAuth access tokens in TAS are JWTs. They:
<ul>
<li>Are unencrypted. Any app can examine the contents of any token.
<li>Are signed by TAS's master secret key. Tokens are always issued by TAS. Any app can verify that any token has been signed by TAS.
<li>Are self-contained. They can be examined and verified by the consuming app without any communication with TAS itself.
</p>

<p>The examples below assume that the incoming API call has arrived at the "GET /categories" (an API defined by
developer "tas") endpoint on the producing app.
</p>

<h4>Check the integrity of the token</h4>

<p>Check the signing of the token to check that the JWT was indeed issued by TAS and has not been tampered with.
</p>

<p>An OAuth access token (in this case, a personal token as shown by the presence of the sub field)
 will look something like this:

<div class='codeBlock'>
{
    "sub": {
        "entityID": "ibmidpuswest-10",
        "nameID": "frank@ibm.com"
    },
    "cons": {
        "ct": "acme",
        "cad": "tas",
        "ca": "uberapply",
        "sgen": 219
    },
    "aud": {
        "pt": "acme",
        "pad": "hrsoft",
        "pa": "ats",
        "sgen": 12
    },
    "iat": "31 Dec 2014",
    "exp": "31 Dec 2014"
}
</div>
</p>

<h4>Audience checks</h4>

<p>The producing app MUST check that it is the correct audience, i.e.:

<ol>
<li>The "pt" (producing tenant) field must match the current tenant (i.e. as extracted from the incoming request)
<li>The "pad" (producing app developer) and "pa" (producing app) fields must match the values hard-coded into this app
</ol>

<p>This check prevents a malicious app using a token for your app which was intended for another app.
</p>


<h5>API checks</h5>

<p>The producing app MUST check that the API call being made is allowed, i.e. that:

<ul>
<li>a route exists from the consuming app install to the producing app install
<li>a valid method is being used (GET, POST, etc.)
</ul>
</p>

<p>This prevents a malicious app calling an API on your app which it has not declared that it calls.
</p>

<p>For example, using the data from the access token above (the "aud" field contains the producer details, so named
for consistency with the JWT spec), the producing app would concatenate details of its own endpoint to the from
and to details from the token to make the core API call:

<div class='codeBlock'>
GET /routes/acme/tas/uberapply/acme/hrsoft/ats/tas/%2Fcategories
</div>
</p>

<p>Note the endpoints should be unaware of whether they are being called as SoT or non-SoT. The call
above will return the route details if it exists as either SoT or non-SoT (API consumption by an
app must be one or the other but not both).

<div class='codeBlock'>
Response:
<div class='clientInclude' data-href='../examples/route-simple.json'></div>
</div>

<p>A return code of 200 means that the route exists and is currently valid.
</p>

<p>Finally the producing app should check that the method being used is one of the methods declared:
<ul>
<li>by the consuming app as being consumed
<li>by the producing app as being produced
</ul>

<p>In this case, the incoming call was to "GET /categories", and GET is supported by the producer and
declared as consumed by the consumer, so the test passes.
</p>

<h3>Caching API check results</h3>

Because API checks as described above involve making TAS core API calls, the producing app should
attempt to cache the results whenever possible.

<h4>Intra-tenant API calls</h4>

<p>For intra-tenant calls (i.e., where the producer and the consumer are the same), the
producer can cache route verifications as long as the "sgen" (security generation) parameter
in the token matches the app's own stored value for sgen.
</p>

<p>This works because sgen cannot be changed without bouncing the tenant, and every app is always
informed when the tenant is bounced, so the producer always knows it has the latest value for
sgen.
</p>

<p>A typical cache implementation might:
<ul>
<li>store verification outcomes for intra-tenant calls as booleans in a key value store
<li>key the outcomes by something like /routes/acme/tas/uberapply/acme/hrsoft/ats/tas/%2Fcategories/GET
<li>flush the cache whenever sgen changes
</ul>

<h4>Inter-tenant API calls</h4>

<p>For inter-tenant calls (i.e. where the consumer is a remote app likely installed at another tenant),
the producer does not receive any notifications when the remote tenant is bounced. Therefore it
has not way to maintain an up to date copy of the remote tenant's sgen value.
</p>

<p>This means that  current has no way to know that a reconfiguration has not happened at the remote consumer,
and so has to verify the route every time.
</p>


<h2>Responding to reboots</h2>

<p>To respond correctly to reboots, your app's control server should produce the core out APIs:
<ul>
<li>/tenants/{}/preHalts
<li>/tenants/{}/halts
<li>/tenants/{}/preStarts
<li>/tenants/{}/starts
</ul>
</p>

<p>See section on reboots for more information.</p>

<h2>Promote your app</h2>

<p>Request that your app be listed in the TAS directory.
</p> 

<h2>Demo-ware</h2>

<p>Exporting a shopping list of apps.</p> 

  
<h1>Core APIs</h1>

<p>Core API calls are secured using the same HMAC approach as
<a href='http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html'>Amazon Web Service's Signature Version 4 signing process</a>,
and see also http://security.stackexchange.com/questions/77372/unusual-design-aspects-of-aws-hmac-based-authentication-v4),
except that whereas an AWS signature key
is generated like this (see http://docs.aws.amazon.com/general/latest/gr/signature-v4-examples.html)...

<div class='codeBlock'>
static byte[] getSignatureKey(String key, String dateStamp, String regionName, String serviceName) throws Exception  {
     byte[] kSecret = ("AWS4" + key).getBytes("UTF8");
     byte[] kDate    = HmacSHA256(dateStamp, kSecret);
     byte[] kRegion  = HmacSHA256(regionName, kDate);
     byte[] kService = HmacSHA256(serviceName, kRegion);
     byte[] kSigning = HmacSHA256("aws4_request", kService);
     return kSigning;
}
</div>
</p>

<p>A TAS signature key for a core API call (in or out) is generated like this...

<div class='codeBlock'>
static byte[] getSignatureKey(String key, String dateStamp) throws Exception  {
     byte[] kSecret = ("TAS4" + key).getBytes("UTF8");
     byte[] kDate    = HmacSHA256(dateStamp, kSecret);
     byte[] kSigning = HmacSHA256("tas4_request", kService);
     return kSigning;
}
</div>
</p>

<p><b>Note:</b> this approach relies on the app's public key (e.g. "tas-simpleapply") being visible in the API request
so that TAS knows what private key to use for decryption...details...

<p>The same applies to coreOut API calls -the app's control server needs to be able to extract app name from the
API request, so that a single control server can serve multiple apps.   
</p>

<h1>Reboots</h1>

<p>A reboot is the process of TAS performing an orderly shutdown and startup of all of the installed apps for a specific tenant whenever major
changes are made to the tenant.
</p>

<p>To play its part correctly when a reboot happens, your app's control server should produce the reboot APIs.
TAS then consumes these APIs during the reboot:

<ul>
<li>/tenants/{}/preHalts
<li>/tenants/{}/halts
<li>/tenants/{}/preStarts
<li>/tenants/{}/starts
</ul>

<p>As a reboot happens, TAS maintains a set of history events that the storefront app can use to feed a progress dialogue. 
</p>

<h2>How the storefront prepares a reboot</h2>

<p>A reboot is initiated as a result of a tenant's actions in the storefront app's UI:
<table border=1>
<thead>
<tr><td>tenant action</td><td>storefont app makes core API call</td><td>example reboot events</td></tr>
</thead>
<tbody>
<tr>
<td>click "install" or "uninstall" on an app</td>
<td>POST /tenants/{}/patchSets</td>
<td><a href='../examples/rebootStatus-juggleApps.json'>example events</a></td>
</tr>
<tr>
<td>click the "reboot" button in the storefront</td>
<td>POST /tenants/{}/reboots</td>
<td><a href='../examples/rebootStatus-simpleReboot.json'>example events</a></td>
</tr>
<tr>
<td>click the "flush OAuth tokens" button in the storefront</td>
<td>POST /tenants/{}/OAuthFlushes</td>
<td><a href='../examples/rebootStatus-bumpSecurityGeneration.json'>example events</a></td>
</tr>
</tbody>
</table>

<h2>How the storefront launches a reboot</h2>

<p>When the storefront app calls the APIs above, the reboot does not start immediately. Instead, the APIs
return a launch key.
</p>

<p>To actually start a reboot, the storefront app (typically from within a web page's
onClick handler of a "Continue" button) uses this launch key
to make a call to <a href='../generated/coreIn.raml.html#_tenants__tenant__reboots__launchKey__post'>POST /tenants/{}/reboots/launchKey/{}</a>.
</p>

<p>As a reboot happens, TAS maintains the event history, and also a status for:
<ul>
<li>the tenant as a whole (see 
<a href='../schemas/tenantStatus.json'>tenantsStatus.json</a>)
<li>each individual app
</ul>  
</p>

<h2>Order of events during reboot</h2>

<p>During a reboot, the order of events is:

<ol>
<li>Halt all apps
<ol>
<li>TAS sets the tenant's status to "preHalting"
<li>TAS calls /tenants/{}/preHalts on each installed app
<li>When the last app returns 200, TAS sets the tenant's status to "preHalted"
<li>TAS sets the tenant's status to "halting"
<li>TAS calls /tenants/{}/halts on each installed app
<li>When the last app returns 200, TAS sets the tenant's status to "halted"
</ol>
<li>TAS increments tenant.incarnation
<li>TAS performs the actual operation, i.e.:
<ul>
<li>do nothing (if this reboot is in response to a call to POST /tenants/{}/reboots)
<li>apply the patch set, e.g. to install an app (if this reboot is in response to a call to POST /tenants/{}/patchSets)
<ul>
<li>apps are installed or uninstalled
<li>routes are adjusted
</ul> 
<li>increment tenant.securityGeneration
<ul>
<li>explicitly (if this reboot is in response to a call to POST /tenants/{}/OAuthFlushes, i.e. the tenant clicked "Flush OAuth tokens"); or
<li>implicitly (if this reboot is in response to a call to POST /tenants/{}/patchSets and
TAS finds that the patch set is making changes to the tenant's idps or assertion hooks)
</ul>
</ul>
<li>Start all apps
<ol>
<li>TAS sets the tenant's status to "preStarting"
<li>TAS calls /tenants/{}/inits on each installed app
<li>When the last app returns 200, TAS sets the tenant's status to "preStarted"
<li>TAS sets the tenant's status to "starting"
<li>TAS calls /tenants/{}/starts on each installed app
<li>When the last app returns 200, TAS sets the tenant's status to "starting"
</ol>
</ol>


<h1>Misc.</h1>

<h2>TAS namespacing</h2>

<p>Any developer is free not just to consume or produce, but also to define tenant APIs within TAS, using any URI template they want, even
if it matches a URI template of an API owned by some other developer.
</p>

<p>Rather than using a "first in, first served" system for URI templates, which would be vulnerable to name squatting, in TAS all tenant APIs are
identified not just by their URI, but also by the name of the developer who defined the API. So there may be multiple
<b>/openings</b> APIs defined, e.g.:
<ul>
<li><b>&lt;tas&gt;/openings</b> (defined by Talent App Store Ltd)
<li><b>&lt;smartsoft&gt;/openings</b> (defined by SmartSoft Corp.)
<li><b>&lt;acme-int&gt;/openings</b> (defined by Acme Corp.)
</ul>
</p>

<p>When apps make API calls to each other, they are always targeted at a specific developer + URI template. 



<h2>Tenant API versioning</h2>

<p>The developer who owns a tenant API is in control of that API's definition.</p>

<p>Any changes to an API definition should be made in a non-breaking style, (thanks
<a href='https://wiki.openstack.org/wiki/APIChangeGuidelines'>openstack</a>):</p>

<h4>Generally acceptable</h4>
<ul>
<li>Adding a new response header
<li>Adding a property to a resource representation
<li>The change is the only way to fix a security bug
<li>Fixing a bug so that a request which resulted in an error response before is now successful
<li>Changing an error response code to be more accurate
<li>Adding an optional property to a resource representation which may be supplied by clients,
assuming the API previously would ignore this property
</ul>
<h4>Generally not acceptable</h4>
<ul>
<li>A change such that a request which was successful before now results in an
error response (unless the success reported previously was hiding an existing error condition)
<li>Changing or removing a property in a resource representation
<li>Changing the semantics of a property in a resource representation which may be supplied by clients
<li>Changing or removing a response header
<li>Changing which response code is returned on success
</ul>

<p>If you need to make a breaking change, you should define a new tenant API instead.</p>



<h1>Well-known SAML attributes</h1>

<p>Whenever a principal logs into an SSO-protected app, the app is passed a SAML assertion, containing a set of attributes.
</p>

<p>TAS defines two well known sets of attributes - personal detail and role - that apps can examine
(perhaps using the TAS-supplied Java libraries) to be informed about the logged in user.
</p>

<p>Personal detail attributes are named <b>"tas.personal.*"</b>, and hold the user's given (first) name, family (last) name, email and image.
These might be useful for the app to customise web pages (e.g., "Welcome, Fred Bloggs"), and/or to populate user records
(e.g. when doing just-in-time provisioning of users when they first log in). These attributes must be of type string.
</p>

<p>Role attributes named <b>"tas.role.*"</b> hold the user's membership of a given role. These might be useful for the app to
do user-based authentication checks, e.g. is this person allowed to see this web page? And if so, what menu items should they see?
These attributes must be of type boolean, with a value of true.
</p>


<p>The following example shows that the logged in candidate has the name Fred Bloggs, and holds the role "internal".  
<div class='codeBlock'>
...
&lt;saml:Attribute NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified" Name="tas.personal.givenName"&gt;
	&lt;saml:AttributeValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="xs:string"&gt;Fred&lt;/saml:AttributeValue&gt;
&lt;/saml:Attribute&gt;
&lt;saml:Attribute NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified" Name="tas.personal.familyName"&gt;
	&lt;saml:AttributeValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="xs:string"&gt;Bloggs&lt;/saml:AttributeValue&gt;
&lt;/saml:Attribute&gt;
&lt;saml:Attribute NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified" Name="tas.role.internal"&gt;
	&lt;saml:AttributeValue xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="xs:boolean"&gt;true&lt;/saml:AttributeValue&gt;
&lt;/saml:Attribute&gt;
</div>
</p>


<h2>Injecting well-known attributes</h2>
 
 <p>As for any other SAML attributes, the well-known attributes may be attached by the idp that principal logged in with. This approach
 allows the tenant to use their idp as a single source of truth about theie users, and the roles that they hold.
 </p>
 
 <p>However TAS also provides mechanisms for the well-known attributes to be injected into the SAML assertion after it has
 been produced by the idp, but before it is passed to the SSO app.
</p>

<h3>Injecting personal detail attributes - mapping document</h3>

<p>Tenants can set up per-idp <b>mapping documents</b> to convert arbitrarily named incoming SAML attributes to their well-known personal detail
equivalents. This is useful when the tenant has limited control over the naming of their SAML attributes.
</p>

<p>For example, perhaps acme's idp always attaches first name in an attribute named "acme.first.name", and this can't be easily changed.
To work around this, acme could set up a mapping document for that idp like this:

<div class='codeBlock'>
<div class='clientInclude' data-href='../examples/attributeMappings-simple.json'></div>
</div>
</p>


<h3>Injecting role attributes - assertion hooks</h3>

<p>Tenants can set up <b>assertion hooks</b> to check for patterns in named SAML assertions (email addresses are often used),
and conditionally insert role attributes.
</p>

<p>As well as injecting roles, assertion hooks can also be used to deny login altogether.
</p>

<p>The assertion hooks below:
<ul>
<li>prevent any AOL user from logging in at all
<li>grant the role of "recruiter" to anyone with the email fred@gmail.com
<li>grant the role of "hrAppViewer to everyone
</ul>
</p>

<p>
<div class='codeBlock'>
<div class='clientInclude' data-href='../examples/assertionHooks-simple.json'></div>
</div>
</p>


<h3>Injecting role attributes - assertion decorator apps</h3>

<p>Special marked <b>assertion decorator</b> apps are called at login time to allow them to inject role attributes.
</p>

<p>As well as injecting roles, session decorator apps can also deny login altogether.
</p>

<p>
For example, TAS makes the following call to an assertion decorator app: 
<div class='codeBlock'>
POST /tenants/{tenant}/logins/{pd}/{pt}/{nameID}

Response:
[ "alumni" ]
</div>
</p>

<p>The response indicates to TAS that it should merge in a role attribute for the role "alumni".


<h3>Order of operations</h3>

<p>TAS performs the above actions in the following order:
<ol>
<li>Apply mapping document
<li>Apply assertion hooks
<li>Invoke assertion decorator apps (in alphebetical order of app name)
</ol>
</p>

<p>
For example: 
<div class='codeBlock'>


+------------------+
|external SAML IdP |
+------------------+
   |
   ...
   | incoming SAML attributes:
   | acme.first.name = Barry
   | acme.last.name = Barry
   | acme.email = bg@acme.com
   |
+--------------------+
| attribute mapping  |
+--------------------+
   |
   | tenant's mapping document:
   | [
   |     {
   |         "tas.personal.givenName": "acme.first.name"
   |     },
   |     {
   |         "tas.personal.familyName": "acme.last.name"
   |     }
   | ]   
   |
   | resulting SAML attributes:
   | tas.personal.givenName = Barry
   | tas.personal.familyName = Gibb
   | tas.personal.email = bg@acme.com
   |
+-----------------+
| assertion hooks |
+-----------------+
   |
   | tenant's assertion hooks:
   | [
   |     {
   |         "injectRoles": {
   |             "condition": {
   |                 "attribute": "tas.personal.email",
   |                 "wildCard": "*.acme.com"
   |             },
   |             "roles": [
   |                 "internal"
   |             ]
   |         }
   |     }
   | ]   
   |
   | resulting SAML attributes:
   | tas.personal.givenName = Barry
   | tas.personal.familyName = Gibb
   | tas.personal.email = bg@acme.com
   | tas.role.internal = true
   |
+--------------------------+
| assertion decorator apps |
+--------------------------+
   |
   | TAS calls POST /tenants/{tenant}/logins/{pd}/{pt}/{nameID}
   | Response:
   | 200
   | [ "alumni" ]
   |
   | resulting SAML attributes:
   | tas.personal.givenName = Barry
   | tas.personal.familyName = Gibb
   | tas.personal.email = bg@acme.com
   | tas.role.internal = true
   | tas.role.alumni = true
   |
+------------------------------+
|TAS session document creation |
+------------------------------+
</div>
</p>

<h2>SAML assertion and auto-provisioning</h2>

<p>Auto-provisioning refers to creating users "on the fly", i.e. at the time when they first log in to the app.
</p>

<p>To decide whether, and how, to auto-provisioning a new logging in user, an app may look at the
well known attributes in the SAML assertion, such as email or roles.</p>

<p>It is possible for an app to be both auto-provisioning and also an assertionDecorator.</p>

<p>In a situation where an assertionDecorator app is asked to decorate the assertion for a user that does not exist in the app, but would due
to auto-provisioning were they to log in to the app, then the app should normally decorate the assertion just as if the user had been
auto-provisioned.</p>

<p>This sort of situation would arise, for example with a legacy ATS app designed to auto-provision new users and grant them access to a
separate candidate search app. In this case, if the user logs in to the search app first, having never visisted the legacy ATS app, then
the legacy ATS app (acting as an assertionDecorator) should inject roles (possibly including the right to access the search app)
as if the user had instead logged into the ATS first and therefore been auto-provisioned and gained the default permissions.</p>
 

<h1>Storefront apps</h1>

<p>Storefront apps are specially privileged apps that perform actions on TAS itself, like installing apps, adding identity sources, etc.<p>

<p>Storefront apps need to be tagged as "storeFront" by TAS support. Please contact TAS if you want to build a storefront app.</p>

<p>In theory multiple storefront apps can coexist within the same tenant.<p>


<h2>Patching a store</h2>

<p>All changes to a store's configuration - i.e. installs, edits or uninstalls of the apps and identity sources making up the store - 
are made via patch documents (documents that conform to the HTTP PATCH semantics described in https://tools.ietf.org/html/rfc6902).</p>

<p>As per the RFC, all changes in the patch set are made with a single atomic transaction.</p>

<h3>Additional patch semantics</h3>

<p>TAS supports an additional id-based path style inspired by SCIM (https://tools.ietf.org/html/draft-ietf-scim-api-12), except that EMCA script is used, e.g.:</p>

<p>This path points to the installed app "tas-legacyats".</p>

<div class='codeBlock'>
"path": "installs[app=='tas-legacyats']"
</div>

<h3>Patch examples</h3>

<p>This example updates the baseUri on the "main" server of the installed app "tas-legacyats".</p>

<div class='codeBlock'>
PATCH /{tenant}
[
{ "op": "replace", "path": "installs[app=='tas-legacyats'].servers[name=='main'].baseUri", "value": "https://newlocation.com/api"
]
</div>


<p>This example installs the app "zongo" from the developer "zwarg", after first checking that the store is still at incarnation 23.</p>

<div class='codeBlock'>
PATCH /{tenant}
[
  { "op": "test", "path": "status.incarnation", "value": 23 },
  { "op": "add", "path": "status.installs.-", "value": {"app": "zwarg-zongo"} }
]
</div>

<p>This example installs an app with a server override (i.e., a non-multi tenanted app such as a legacy ATS).</p>

<div class='codeBlock'>
PATCH /{tenant}
[
  { "op": "test", "path": "/incarnation", "value": 23 },
  { "op": "add", "path": "/installs/-", "value": {"app": "tas-legacyats", "servers": [{"name": "ats0", "basicAuthCredentials": {"user": "fred", "password": "secret1"}}]} }
]
</div>

<p>This example changes the password for the previously installed app:</p>

<div class='codeBlock'>
PATCH /{tenant}
[
  { "op": "test", "path": "/incarnation", "value": 23 },
  { "op": "add", "path": "/installs/6/servers/0/basicAuthCredentials/password", "value": "secret2" }
]
</div>

<p>This example sets up a new tenant:
<ol>
<li>creates the store for a new tenant "acme"
<li>installs the storefront app
<li>installs a single identity source for the bootstrap IdP
<li>hardcodes all people in the bootstrap IdP as "hrStoreAppAdmin" and "hrStoreIdentityAdmin", so that they can manage the store.
</ol>
</p>


<div class='codeBlock'>
PATCH /{tenant}
[
{
    "op": "add",
    "path": "/",
    "value": {
        "details": {
            "organizationName": "ACME Corporation",
            "shortCode": "acme",
            "description": "A test site while we see if this stuff works",
            "country": "US",
            "industry": "Manufacturing"
        },
        "installs": [
            {
                "app": "tas-storefront"
            }
        ],
        "identitySourceSets": [
            {
                "principalDeveloper": "tas",
                "principalType": "user",
                "identitySources": [
                    {
                        "kind": "bootstrapIdentitySource",
                        "description": "The store owner automatically gets access to manage the store",
                        "attributeOverrides": [
                            {
                                "filter": "*",
                                "ifMatched": [
                                    {
                                        "name": "tas-user-roles",
                                        "values": [
                                            "hrStoreIdentityAdmin",
                                            "hrStoreAppsAdmin",
                                            "hrStoreViewer"
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        ]
    }
}
]
</div>

<h2>Applying a patch</h2>

<p>To apply a patch document to a tenant, your storefront app makes a series of API calls, as shown in the example below:<p>

<ol>
<li>The user (an HR admin person) is at the app details page within your storefront web site.</li>
<li>They click install on the app, submitting a web form</li>
<li>Your app's server code composes a patch document based on the user's input.</li>
<li>Your app's server code POSTS to /{tenant}/patchSets, with:
<ol>
<li>the patch document
<li>the continue page, i.e. where the storefront would like the user to end up on completion
</ol>
..and checks for errors.</li>
<li>The response from TAS contains a signed JWT, which embeds the original patch document and the continue page.</li>
<li>Your server code inserts the JWT into the onClick handler of a new "confirm" button on the app details page.</li>
<li>The user is now back at the app details page. They click confirm.</li>
<li>The browser opens a progress dialog.</li>
<li>The browser submits the JWT, including the original patch document, via an ajax call to PATCH /{tenant}.</li>
<li>The call returns immediately with a launch key and the first few items of the patch log.</li>  
<li>The browser writes the patch log to the progress dialog.</li>
<li>The browser immediately makes another ajax call to GET /{tenant}/patchLaunches/{launchKey}
<li>This is a long polling method, which returns as soon as any new patch log items are available.</li>
<li>The browser loops, making repeated ajax calls to GET /{tenant}/patchLaunches/{launchKey} and adding new log messages to the progress dialog, until the operation is complete.</li>
<li>The final response from GET /{tenant}/patchLaunches/{launchKey} includes the URI of the continue page.
<li>The browser displays a "patch complete" message to the user, and a "Continue" button.
<li>On pressing Continue, the user is redirected to the continue page.
<li>We're done.  
</ol> 

<p>The complexity of the interactions, and the use of JWTs, is necessary:
<ul>
<li>to allow the progress dialog to continue throughout, even when
<ul>
<li>the storefront app itself is stopped and started like all other apps as the patch set is applied</li>
<li>the storefront app is swapped out for another one as part of the changes</li>
</ul>
<li>to reflect the insecure nature of making ajax calls from the browser
</ul>

<h2>How TAS applies patch sets</h2>

<p>To apply a patch set, TAS does the following:
<ol>
<li>requests each already installed app to shut down</li>
<li>applies the set</li>
<li>resets all volatile credentials for the tenant:
<ul>
<li>The tenant's own private/public key pair (as obtained via GET /{tenant})
<li>All HMAC signing keys (as held on routes)
</ul>
<li>Increments the tenant's incarnation (thus invalidating all existing OAuth tokens)
<li>detects whether the delta set includes uninstalling the app that created tha launcher, and if
so calls GET /m/storeFrontMainPage to get a new continue page. Note this prevents an about-to-be-uninstalled storefront
from specifying any continue page, not just a page on itself.
<li>sends startup requests to each installed app</li>
</ol>
</p>

<p>In parallel to the above, TAS causes any outstanding long polling calls to GET /{tenant}/patchSetLaunches to return
each time there is a new available event. A maximum of 100 events are returned per call.</p>


<h2>Bootstrap patch set</h2>

<p>As well as patching existing tenants, storefront apps can also create new tenants, for example:

<ul>
<li>when a new tenant creates their store
<li>when an existing tenant copies their store (e.g. to create a testing/sandbox site)
</ul>
</p>
 
<p>POST /tenantBootstraps/{tenant}</p>

<p>Once this launch is complete, the storefront app can take over the UI. TAS will call GET /storeFrontMain.</p>



<h1>Portfolio apps</h1>

<p>TAS apps operate, and call each other via tenant APIs, solely within the context of a tenant.
For example, it is not possible for (and TAS will not issue or validate tokens for) a consuming app
running on behalf of one tenant to make a API call to a producing app running on behalf of another tenant.</p>

<p>However some apps may also want to present a public face, not associated with any specific tenant.</p>

<p>For example, a job board (say, for plumbers) may present a public web site (www.plumberjobs.com) where candidates can register and profile themselves. In this situation, a candidate should be able:
<ol>
<li>authenticate (e.g. via Google) and profile themselves at www.plumberjobs.com
<li>at a later date, authenticate via the same Google account and apply for a plumbing job at a tenant, and access the information from their previously set up profile.
</ol>

<p>This can be achieved via a setup like the following:

<ol>
<li>www.plumberjobs.com is implemented as an (unlisted) app intended to be used only once, to power the www.plumberjobs.com website
<li>The app is linked to the &lt;tas&gt; candidate principal type, and therefore can therefore protect its own pages via the TAS SSO system
<li>The developer creates a tenant
<li>The tenant installs the app
<li>The tenant links the &lt;tas&gt; candidate principal type to common/global identity sources (e.g. Google, Facebook, LinkedIn)
<li>The site is now live, and can start capturing plumbers, who protect their details using their preferred login mechanism (e.g. Facebook)
<li>The developer now creates a second (listed) app, "plumbersbackend"
<li>That app implements the well-known non-SoT API /m/candidates/{}
<li>[complete..]      
</ol>


<script>
$(document).ready(function() {

	renderSequenceDiagrams();
	renderClientIncludes();
	renderTOC();
});
</script>


</body>
</html>